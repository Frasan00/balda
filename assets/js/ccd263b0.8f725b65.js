"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3956],{8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>i});var s=n(6540);const t={},o=s.createContext(t);function a(e){const r=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:r},e.children)}},9112:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core-concepts/routing","title":"Routing","description":"Balda provides flexible routing through direct server registration, the router singleton, or controller decorators.","source":"@site/docs/core-concepts/routing.md","sourceDirName":"core-concepts","slug":"/core-concepts/routing","permalink":"/balda/docs/core-concepts/routing","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/balda/tree/main/docs/docs/core-concepts/routing.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docs","previous":{"title":"Controllers","permalink":"/balda/docs/core-concepts/controllers"},"next":{"title":"Middleware","permalink":"/balda/docs/core-concepts/middleware"}}');var t=n(4848),o=n(8453);const a={sidebar_position:3},i="Routing",d={},l=[{value:"Route Registration Methods",id:"route-registration-methods",level:2},{value:"1. Direct Server Routes",id:"1-direct-server-routes",level:3},{value:"2. Router Singleton",id:"2-router-singleton",level:3},{value:"3. Controller Decorators",id:"3-controller-decorators",level:3},{value:"Route Parameters",id:"route-parameters",level:2},{value:"Path Parameters",id:"path-parameters",level:3},{value:"Query Parameters",id:"query-parameters",level:3},{value:"Route Patterns",id:"route-patterns",level:2},{value:"Route Precedence",id:"route-precedence",level:2},{value:"Type-Safe Routing",id:"type-safe-routing",level:2},{value:"Path Parameters",id:"path-parameters-1",level:3},{value:"Type-Safe Responses",id:"type-safe-responses",level:3},{value:"Controller Type Safety",id:"controller-type-safety",level:3},{value:"Route Options",id:"route-options",level:2},{value:"Validation Options",id:"validation-options",level:3},{value:"Route Groups",id:"route-groups",level:2}];function c(e){const r={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"routing",children:"Routing"})}),"\n",(0,t.jsx)(r.p,{children:"Balda provides flexible routing through direct server registration, the router singleton, or controller decorators."}),"\n",(0,t.jsx)(r.h2,{id:"route-registration-methods",children:"Route Registration Methods"}),"\n",(0,t.jsx)(r.h3,{id:"1-direct-server-routes",children:"1. Direct Server Routes"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:'import { Server, router } from "balda";\nimport { z } from "zod";\n\nconst server = new Server({ port: 3000 });\n\n// Simple routes\nrouter.get("/users", (req, res) => res.json({ users: [] }));\nrouter.post("/users", (req, res) => res.created(req.body));\nrouter.put("/users/:id", (req, res) => res.json({ id: req.params.id }));\nrouter.delete("/users/:id", (req, res) => res.noContent());\n\n// With inline validation - validated data injected as parameters\nconst CreateUserSchema = z.object({\n  name: z.string().min(1),\n  email: z.string().email(),\n});\n\nrouter.post(\n  "/users/validated",\n  {\n    body: CreateUserSchema,\n  },\n  (req, res, validatedBody) => {\n    // validatedBody is typed and validated automatically\n    res.created({ id: "123", ...validatedBody });\n  },\n);\n\n// With options\nrouter.post(\n  "/users",\n  {\n    middlewares: [authMiddleware],\n    body: CreateUserSchema,\n    swagger: {\n      name: "Create User",\n      responses: {\n        201: UserResponseSchema,\n      },\n    },\n  },\n  (req, res, validatedBody) => {\n    res.created(validatedBody);\n  },\n);\n'})}),"\n",(0,t.jsx)(r.h3,{id:"2-router-singleton",children:"2. Router Singleton"}),"\n",(0,t.jsx)(r.p,{children:"Useful for modular route definitions:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:'import { router } from "balda";\nimport { z } from "zod";\n\n// Simple routes\nrouter.get("/health", (req, res) => res.json({ status: "ok" }));\n\n// With inline validation\nconst LoginSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n});\n\nrouter.post(\n  "/login",\n  {\n    body: LoginSchema,\n  },\n  (req, res, credentials) => {\n    // credentials is validated automatically\n    const { email, password } = credentials;\n    res.json({ token: generateToken(email, password) });\n  },\n);\n\n// Query validation\nconst SearchSchema = z.object({\n  q: z.string(),\n  page: z.coerce.number().default(1),\n});\n\nrouter.get(\n  "/search",\n  {\n    query: SearchSchema,\n  },\n  (req, res, query) => {\n    // query parameters are validated and type-coerced\n    res.json({ results: [], query: query.q, page: query.page });\n  },\n);\n'})}),"\n",(0,t.jsx)(r.h3,{id:"3-controller-decorators",children:"3. Controller Decorators"}),"\n",(0,t.jsx)(r.p,{children:"Recommended for organized, feature-based routing:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:'import { controller, get, post } from "balda";\n\n@controller("/users")\nexport class UsersController {\n  @get("/") getAll(req, res) {\n    res.json({ users: [] });\n  }\n  @get("/:id") getById(req, res) {\n    res.json({ id: req.params.id });\n  }\n  @post("/") create(req, res) {\n    res.created(req.body);\n  }\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["See ",(0,t.jsx)(r.a,{href:"./controllers",children:"Controllers"})," for detailed controller documentation."]}),"\n",(0,t.jsx)(r.h2,{id:"route-parameters",children:"Route Parameters"}),"\n",(0,t.jsx)(r.h3,{id:"path-parameters",children:"Path Parameters"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:'// Single parameter\nrouter.get("/users/:id", (req, res) => {\n  res.json({ id: req.params.id });\n});\n\n// Multiple parameters\nrouter.get("/users/:userId/posts/:postId", (req, res) => {\n  const { userId, postId } = req.params;\n  res.json({ userId, postId });\n});\n'})}),"\n",(0,t.jsx)(r.h3,{id:"query-parameters",children:"Query Parameters"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:'router.get("/users", (req, res) => {\n  const { page = 1, limit = 10, search } = req.query;\n  res.json({ page: Number(page), limit: Number(limit), search });\n});\n'})}),"\n",(0,t.jsx)(r.h2,{id:"route-patterns",children:"Route Patterns"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:'// Static route\nrouter.get("/about", (req, res) => res.json({ message: "About" }));\n\n// Dynamic parameter\nrouter.get("/users/:id", (req, res) => res.json({ id: req.params.id }));\n\n// Optional parameter\nrouter.get("/posts/:id?", (req, res) => {\n  req.params.id ? res.json({ id }) : res.json({ posts: [] });\n});\n\n// Wildcard\nrouter.get("/files/*", (req, res) => {\n  res.json({ filePath: req.params["*"] });\n});\n'})}),"\n",(0,t.jsx)(r.h2,{id:"route-precedence",children:"Route Precedence"}),"\n",(0,t.jsx)(r.p,{children:"Routes are matched in registration order. Define specific routes before general ones:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:'// Specific first\nrouter.get("/users/admin", (req, res) => res.json({ admin: true }));\n// General after\nrouter.get("/users/:id", (req, res) => res.json({ id: req.params.id }));\n'})}),"\n",(0,t.jsx)(r.h2,{id:"type-safe-routing",children:"Type-Safe Routing"}),"\n",(0,t.jsx)(r.p,{children:"Balda provides automatic type inference for both path parameters and response bodies."}),"\n",(0,t.jsx)(r.h3,{id:"path-parameters-1",children:"Path Parameters"}),"\n",(0,t.jsx)(r.p,{children:"Path parameters are automatically inferred from the route path string:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:"// Path parameters are inferred \u2014 no manual typing needed\nrouter.get('/users/:id', (req, res) => {\n  const { id } = req.params; // \u2705 Typed as { id: string }\n  res.json({ id });\n});\n"})}),"\n",(0,t.jsx)(r.h3,{id:"type-safe-responses",children:"Type-Safe Responses"}),"\n",(0,t.jsxs)(r.p,{children:["When you define response schemas in the ",(0,t.jsx)(r.code,{children:"swagger.responses"})," option, Balda ",(0,t.jsx)(r.strong,{children:"automatically infers"})," the response body types for each status code. This works with Zod, TypeBox, and plain JSON schemas:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:'import { z } from \'zod\';\n\nconst UserSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  email: z.string(),\n});\n\nconst ErrorSchema = z.object({\n  error: z.string(),\n});\n\nrouter.get(\n  \'/users/:id\',\n  {\n    swagger: {\n      responses: {\n        200: UserSchema,\n        404: ErrorSchema,\n      },\n    },\n  },\n  (req, res) => {\n    const { id } = req.params; // \u2705 Typed as { id: string }\n\n    res.ok({ id, name: "John", email: "john@example.com" }); // \u2705 Typed as { id: string; name: string; email: string }\n    res.notFound({ error: "User not found" });                // \u2705 Typed as { error: string }\n\n    // res.ok({ wrong: 123 });           // \u274c Type error \u2014 doesn\'t match UserSchema\n    // res.notFound({ wrong: "value" }); // \u274c Type error \u2014 doesn\'t match ErrorSchema\n  },\n);\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Each shorthand method (",(0,t.jsx)(r.code,{children:"ok()"}),", ",(0,t.jsx)(r.code,{children:"created()"}),", ",(0,t.jsx)(r.code,{children:"notFound()"}),", etc.) is typed to its corresponding status code schema. Methods for unmapped status codes default to ",(0,t.jsx)(r.code,{children:"any"}),"."]}),"\n",(0,t.jsx)(r.admonition,{title:"TypeBox and JSON Schemas",type:"tip",children:(0,t.jsxs)(r.p,{children:["TypeBox schemas provide the same type inference as Zod. Plain JSON Schema objects are also supported but resolve to ",(0,t.jsx)(r.code,{children:"any"})," since they have no TypeScript type representation."]})}),"\n",(0,t.jsx)(r.h3,{id:"controller-type-safety",children:"Controller Type Safety"}),"\n",(0,t.jsxs)(r.p,{children:["For controller-based routes, you can manually type the ",(0,t.jsx)(r.code,{children:"Response"})," generic:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:"import { Request, Response } from 'balda';\n\ntype UserResponse = { id: string; name: string; email: string };\n\n@post('/')\n@validate.body(CreateUserSchema)\nasync create(\n  req: Request<{}>,\n  res: Response<{ 201: UserResponse }>,\n  body: z.infer<typeof CreateUserSchema> // \u2705 Validated & typed\n) {\n  res.created({ id: '123', ...body }); // \u2705 Typed as UserResponse\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["See ",(0,t.jsx)(r.a,{href:"./request-response",children:"Request-Response"})," for more on type-safe requests and responses."]}),"\n",(0,t.jsx)(r.h2,{id:"route-options",children:"Route Options"}),"\n",(0,t.jsxs)(r.p,{children:["All route methods (",(0,t.jsx)(r.code,{children:"get"}),", ",(0,t.jsx)(r.code,{children:"post"}),", ",(0,t.jsx)(r.code,{children:"put"}),", ",(0,t.jsx)(r.code,{children:"patch"}),", ",(0,t.jsx)(r.code,{children:"delete"}),", ",(0,t.jsx)(r.code,{children:"options"}),", ",(0,t.jsx)(r.code,{children:"head"}),") support an optional configuration object:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:'import { z } from "zod";\n\nconst UserSchema = z.object({\n  name: z.string(),\n  email: z.string().email(),\n});\n\nconst QuerySchema = z.object({\n  includeDeleted: z.coerce.boolean().default(false),\n});\n\nrouter.post(\n  "/users",\n  {\n    // Request validation (automatically injects validated data as parameters)\n    body: UserSchema, // Validates and injects as 3rd parameter\n    query: QuerySchema, // Validates and injects as 4th parameter (or 3rd if no body)\n    all: CombinedSchema, // Validates body+query merged (mutually exclusive with body/query)\n\n    // Middleware\n    middlewares: [authMiddleware, validationMiddleware], // or single middleware\n\n    // Swagger documentation\n    swagger: {\n      name: "Create User",\n      description: "Creates a new user",\n      responses: {\n        201: UserResponseSchema,\n        400: ErrorSchema,\n      },\n    },\n  },\n  (req, res, validatedBody, validatedQuery) => {\n    // validatedBody and validatedQuery are typed and validated\n    res.created({ id: "123", ...validatedBody });\n  },\n);\n'})}),"\n",(0,t.jsx)(r.h3,{id:"validation-options",children:"Validation Options"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"body"})}),": Validates request body, injects as 3rd parameter"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"query"})}),": Validates query string, injects as next parameter after body (if present)"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:(0,t.jsx)(r.code,{children:"all"})}),": Validates merged body + query, injects as 3rd parameter (cannot use with ",(0,t.jsx)(r.code,{children:"body"})," or ",(0,t.jsx)(r.code,{children:"query"}),")"]}),"\n"]}),"\n",(0,t.jsx)(r.admonition,{title:"Automatic Swagger Integration",type:"tip",children:(0,t.jsxs)(r.p,{children:["When you specify ",(0,t.jsx)(r.code,{children:"body"})," or ",(0,t.jsx)(r.code,{children:"query"})," at the route level, they're automatically included in Swagger documentation. No need to specify ",(0,t.jsx)(r.code,{children:"requestBody"})," or ",(0,t.jsx)(r.code,{children:"query"})," in the swagger options."]})}),"\n",(0,t.jsx)(r.h2,{id:"route-groups",children:"Route Groups"}),"\n",(0,t.jsxs)(r.p,{children:["Use ",(0,t.jsx)(r.code,{children:"router.group()"})," to organize related routes:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-typescript",children:'import { z } from "zod";\n\n// Basic grouping\nrouter.group("/api/v1", (r) => {\n  r.get("/users", (req, res) => res.json({ users: [] }));\n  r.get("/posts", (req, res) => res.json({ posts: [] }));\n});\n\n// With middleware\nrouter.group("/admin", [authMiddleware, adminMiddleware], (r) => {\n  r.get("/dashboard", (req, res) => res.json({ ok: true }));\n});\n\n// With validation in grouped routes\nrouter.group("/api/v2", (r) => {\n  const CreatePostSchema = z.object({\n    title: z.string(),\n    content: z.string(),\n  });\n\n  r.post(\n    "/posts",\n    {\n      body: CreatePostSchema,\n      middlewares: [authMiddleware],\n    },\n    (req, res, validatedBody) => {\n      res.created({ id: "123", ...validatedBody });\n    },\n  );\n});\n'})}),"\n",(0,t.jsxs)(r.p,{children:["See the ",(0,t.jsx)(r.a,{href:"./server",children:"Server documentation"})," for more details on grouping and middleware."]})]})}function p(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);