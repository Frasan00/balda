"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1935],{6261:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>t,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"queues/overview","title":"overview","description":"Queues Overview","source":"@site/docs/queues/overview.md","sourceDirName":"queues","slug":"/queues/overview","permalink":"/balda/docs/queues/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/balda/tree/main/docs/docs/queues/overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docs","previous":{"title":"Cron UI","permalink":"/balda/docs/cron/ui"},"next":{"title":"publishing","permalink":"/balda/docs/queues/publishing"}}');var i=n(4848),o=n(8453);const t={sidebar_position:1},a=void 0,l={},u=[{value:"Queues Overview",id:"queues-overview",level:3},{value:"Core building blocks",id:"core-building-blocks",level:4},{value:"Best Practice: Centralized Queue Registry",id:"best-practice-centralized-queue-registry",level:4},{value:"Quick start",id:"quick-start",level:4},{value:"Subscription Methods",id:"subscription-methods",level:4},{value:"Alternative: Glob-based handler imports",id:"alternative-glob-based-handler-imports",level:4}];function d(e){const s={code:"code",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h3,{id:"queues-overview",children:"Queues Overview"}),"\n",(0,i.jsx)(s.p,{children:"Balda provides a lightweight, provider-agnostic queue abstraction to publish and consume background jobs with a clean, type\u2011safe API. It ships with first\u2011class providers for BullMQ, AWS SQS, and PGBoss, and allows custom providers."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Typed queue instances"}),": Create fully typed queue instances with factory functions"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Decorator-based consumers"}),": Use ",(0,i.jsx)(s.code,{children:"@queueInstance.subscribe()"})," decorators to subscribe class methods"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Callback-based consumers"}),": Subscribe using callback functions for simpler use cases"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Type safety"}),": Full TypeScript support with generic payload types"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Simple publishing"}),": Call ",(0,i.jsx)(s.code,{children:"queueInstance.publish(payload)"})," on typed queue instances"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"core-building-blocks",children:"Core building blocks"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Factory functions: ",(0,i.jsx)(s.code,{children:"bullmqQueue"}),", ",(0,i.jsx)(s.code,{children:"sqsQueue"}),", ",(0,i.jsx)(s.code,{children:"pgbossQueue"}),", ",(0,i.jsx)(s.code,{children:"createQueue"})," (for custom providers)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"TypedQueue"})," and ",(0,i.jsx)(s.code,{children:"CustomTypedQueue"})," classes for type-safe queue operations"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"defineQueueConfiguration"})," single entrypoint to configure built-in providers"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"QueueService"})," to manage and start all queue subscribers"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"best-practice-centralized-queue-registry",children:"Best Practice: Centralized Queue Registry"}),"\n",(0,i.jsx)(s.p,{children:"While not enforced, the recommended approach is to define all your queues in a centralized location. This provides a single source of truth and makes queues easily importable across your application:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:"// src/queues/index.ts\nimport { bullmqQueue, sqsQueue, pgbossQueue } from 'balda';\n\n// Define payload types\ntype UserEventPayload = { userId: string; action: string };\ntype EmailPayload = { to: string; subject: string; body: string };\ntype NotificationPayload = { userId: string; message: string };\n\n// Export all queues from a single location\nexport const queues = {\n  userEvents: bullmqQueue<UserEventPayload>('user-events'),\n  emails: sqsQueue<EmailPayload>('emails', {\n    queueUrl: 'https://sqs.us-east-1.amazonaws.com/123456789/emails'\n  }),\n  notifications: pgbossQueue<NotificationPayload>('notifications'),\n} as const;\n"})}),"\n",(0,i.jsx)(s.p,{children:"Then import queues wherever needed:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:"import { queues } from './queues/index.js';\n\n// In handlers\n@queues.userEvents.subscribe()\nasync handle(payload: UserEventPayload) { }\n\n// In services\nawait queues.userEvents.publish({ userId: '123', action: 'signup' });\n"})}),"\n",(0,i.jsx)(s.p,{children:"This pattern is optional but highly recommended for larger applications with multiple queues."}),"\n",(0,i.jsx)(s.h4,{id:"quick-start",children:"Quick start"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Create a typed queue instance:"}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:"import { bullmqQueue } from 'balda';\n\n// Define payload type\ntype UserEventPayload = {\n  userId: string;\n  action: string;\n};\n\n// Create typed queue\nexport const userQueue = bullmqQueue<UserEventPayload>('user-events');\n"})}),"\n",(0,i.jsxs)(s.ol,{start:"2",children:["\n",(0,i.jsx)(s.li,{children:"Subscribe to queues (two ways):"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Option A: Decorator-based subscription (recommended for class methods)"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:"export class UserEventHandler {\n  @userQueue.subscribe()\n  async handle(payload: UserEventPayload) {\n    // process job with full type safety\n    console.log(`User ${payload.userId} performed ${payload.action}`);\n  }\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Option B: Callback-based subscription (for standalone functions)"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:"await userQueue.subscribe(async (payload) => {\n  console.log(`User ${payload.userId} performed ${payload.action}`);\n});\n"})}),"\n",(0,i.jsxs)(s.ol,{start:"3",children:["\n",(0,i.jsx)(s.li,{children:"Configure and start subscribers:"}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:"import { QueueService, defineQueueConfiguration } from 'balda';\n\n// Configure queue providers\ndefineQueueConfiguration({\n  bullmq: {\n    connection: { host: '127.0.0.1', username: 'default', password: 'root', db: 0 },\n  },\n});\n\n// Import handlers (this registers decorators)\nimport './handlers/user-events.js';\n\n// Start queue subscribers\nawait QueueService.run();\n\nconsole.log('Queues started');\n\n// Publish a job\nawait userQueue.publish({ userId: '123', action: 'signup' });\n"})}),"\n",(0,i.jsx)(s.h4,{id:"subscription-methods",children:"Subscription Methods"}),"\n",(0,i.jsx)(s.p,{children:"Each queue instance provides two ways to subscribe:"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"1. Decorator-based (best for organized class handlers)"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:"import { bullmqQueue } from 'balda';\n\nconst orderQueue = bullmqQueue<{ orderId: number }>('orders');\n\nexport class OrderHandler {\n  @orderQueue.subscribe()\n  async handle(payload: { orderId: number }) {\n    console.log('Processing order:', payload.orderId);\n  }\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"2. Callback-based (best for simple inline handlers)"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:"import { bullmqQueue } from 'balda';\n\nconst orderQueue = bullmqQueue<{ orderId: number }>('orders');\n\n// Subscribe with callback\nawait orderQueue.subscribe(async (payload) => {\n  console.log('Processing order:', payload.orderId);\n});\n"})}),"\n",(0,i.jsx)(s.p,{children:"Both methods are fully type-safe and provide the same functionality. Choose the approach that best fits your code organization style."}),"\n",(0,i.jsx)(s.h4,{id:"alternative-glob-based-handler-imports",children:"Alternative: Glob-based handler imports"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:"// queue.ts\nimport { QueueService } from 'balda';\nimport path from 'node:path';\n\n// Import all handler files\nawait QueueService.massiveImportQueues([\n  path.join(import.meta.dirname, 'src/queues/**/*.ts')\n]);\n\n// Start all subscribers\nawait QueueService.run();\n"})}),"\n",(0,i.jsx)(s.p,{children:"Continue with configuration and publishing details in the next sections."})]})}function c(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>a});var r=n(6540);const i={},o=r.createContext(i);function t(e){const s=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(o.Provider,{value:s},e.children)}}}]);