"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7634],{96:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"performance/cache-monitoring","title":"Cache Monitoring","description":"Balda provides a comprehensive cache monitoring system to track schema compilation and serialization performance. This is essential for understanding memory usage and optimizing long-running applications.","source":"@site/docs/performance/cache-monitoring.md","sourceDirName":"performance","slug":"/performance/cache-monitoring","permalink":"/balda/docs/performance/cache-monitoring","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/balda/tree/main/docs/docs/performance/cache-monitoring.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Error Handling","permalink":"/balda/docs/core-concepts/error-handling"},"next":{"title":"Caching Overview","permalink":"/balda/docs/cache/overview"}}');var i=s(4848),c=s(8453);const a={},l="Cache Monitoring",t={},o=[{value:"Overview",id:"overview",level:2},{value:"Cache Types",id:"cache-types",level:2},{value:"1. Validator Cache",id:"1-validator-cache",level:3},{value:"2. Serializer Cache",id:"2-serializer-cache",level:3},{value:"3. JSON Schema Cache",id:"3-json-schema-cache",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"<code>getCacheMetrics()</code>",id:"getcachemetrics",level:3},{value:"<code>logCacheMetrics()</code>",id:"logcachemetrics",level:3},{value:"<code>clearAllCaches()</code>",id:"clearallcaches",level:3},{value:"Cache Invalidation Strategy",id:"cache-invalidation-strategy",level:2},{value:"Current Strategy",id:"current-strategy",level:3},{value:"When Caches Are Populated",id:"when-caches-are-populated",level:3},{value:"Cache Warming",id:"cache-warming",level:3},{value:"Memory Considerations",id:"memory-considerations",level:2},{value:"Automatic Garbage Collection",id:"automatic-garbage-collection",level:3},{value:"Long-Running Processes",id:"long-running-processes",level:3},{value:"Memory Estimates",id:"memory-estimates",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"Health Check Endpoints",id:"health-check-endpoints",level:3},{value:"Performance Monitoring Dashboards",id:"performance-monitoring-dashboards",level:3},{value:"Development Debugging",id:"development-debugging",level:3},{value:"Testing Environments",id:"testing-environments",level:3},{value:"Performance Impact",id:"performance-impact",level:2},{value:"Cache Hit vs Miss",id:"cache-hit-vs-miss",level:3},{value:"Memory vs Speed Trade-off",id:"memory-vs-speed-trade-off",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Related APIs",id:"related-apis",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"cache-monitoring",children:"Cache Monitoring"})}),"\n",(0,i.jsx)(n.p,{children:"Balda provides a comprehensive cache monitoring system to track schema compilation and serialization performance. This is essential for understanding memory usage and optimizing long-running applications."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The framework uses three parallel caches for optimal performance:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validator Cache"})," (",(0,i.jsx)(n.code,{children:"openapiSchemaMap"}),") - Compiled AJV validators"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Serializer Cache"})," (",(0,i.jsx)(n.code,{children:"fastJsonStringifyMap"}),") - fast-json-stringify functions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"JSON Schema Cache"})," (",(0,i.jsx)(n.code,{children:"jsonSchemaCache"}),") - Converted JSON schemas for Swagger/OpenAPI"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"All caches use WeakMap-based keys for automatic garbage collection when schemas are no longer referenced."}),"\n",(0,i.jsx)(n.h2,{id:"cache-types",children:"Cache Types"}),"\n",(0,i.jsx)(n.h3,{id:"1-validator-cache",children:"1. Validator Cache"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Stores compiled AJV validators for request/response validation"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Type"}),": Symbol (from WeakMap) or string (for primitives)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Lifecycle"}),": Application lifetime"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Used by"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@validate"})," decorator"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"Request.validate()"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@serialize"})," decorator (when ",(0,i.jsx)(n.code,{children:"throwErrorOnValidationFail: true"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Memory"}),": ~1-5KB per validator"]}),"\n",(0,i.jsx)(n.h3,{id:"2-serializer-cache",children:"2. Serializer Cache"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Stores fast-json-stringify functions for high-performance JSON serialization"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Type"}),": Symbol (shared with validators)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Lifecycle"}),": Application lifetime"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Used by"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@serialize"})," decorator"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Response.json()"})," with schemas"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Memory"}),": ~2-10KB per serializer"]}),"\n",(0,i.jsx)(n.h3,{id:"3-json-schema-cache",children:"3. JSON Schema Cache"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Stores converted JSON schemas for Swagger/OpenAPI documentation"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Type"}),": Symbol (shared with validators and serializers)"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Lifecycle"}),": Application lifetime"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Used by"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Swagger plugin"}),"\n",(0,i.jsx)(n.li,{children:"OpenAPI spec generation"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Memory"}),": ~0.5-2KB per schema"]}),"\n",(0,i.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,i.jsx)(n.h3,{id:"getcachemetrics",children:(0,i.jsx)(n.code,{children:"getCacheMetrics()"})}),"\n",(0,i.jsx)(n.p,{children:"Returns comprehensive metrics about all schema caches."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": ",(0,i.jsx)(n.code,{children:"CacheMetrics"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface CacheMetrics {\n  validators: {\n    size: number;\n    description: string;\n  };\n  serializers: {\n    size: number;\n    schemaRefsCreated: number;\n    entries: Array<{\n      key: string;\n      compiledAt: number;\n      schemaType: string;\n    }>;\n  };\n  jsonSchemas: {\n    size: number;\n    description: string;\n  };\n  totalSchemaReferences: number;\n  memoryEstimate: {\n    validators: string;\n    serializers: string;\n    jsonSchemas: string;\n    total: string;\n  };\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { getCacheMetrics } from 'balda';\n\nconst metrics = getCacheMetrics();\n\nconsole.log(`Validators cached: ${metrics.validators.size}`);\nconsole.log(`Serializers cached: ${metrics.serializers.size}`);\nconsole.log(`JSON schemas cached: ${metrics.jsonSchemas.size}`);\nconsole.log(`Total memory estimate: ${metrics.memoryEstimate.total}`);\nconsole.log(`Schema references created: ${metrics.totalSchemaReferences}`);\n\n// Inspect individual serializer entries\nmetrics.serializers.entries.forEach((entry) => {\n  console.log(`${entry.key}: ${entry.schemaType} (compiled ${Date.now() - entry.compiledAt}ms ago)`);\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"logcachemetrics",children:(0,i.jsx)(n.code,{children:"logCacheMetrics()"})}),"\n",(0,i.jsx)(n.p,{children:"Logs cache metrics using the structured logger (Pino)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": ",(0,i.jsx)(n.code,{children:"void"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { logCacheMetrics } from 'balda';\n\n// Log at server startup\nserver.listen(3000, () => {\n  logCacheMetrics();\n});\n\n// Log periodically for monitoring\nsetInterval(() => {\n  logCacheMetrics();\n}, 60000); // Every minute\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Output format"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "level": 30,\n  "time": 1706543210000,\n  "msg": "Schema cache metrics",\n  "validators": 42,\n  "serializers": 38,\n  "jsonSchemas": 40,\n  "totalSchemaRefs": 45,\n  "memoryEstimate": "~1.2MB"\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"clearallcaches",children:(0,i.jsx)(n.code,{children:"clearAllCaches()"})}),"\n",(0,i.jsx)(n.p,{children:"Clears all schema caches. This forces all schemas to be recompiled on next use."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),": ",(0,i.jsx)(n.code,{children:"void"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Warning"}),": This will impact performance as schemas need to be recompiled. Only use in specific scenarios:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Testing environments"}),"\n",(0,i.jsx)(n.li,{children:"Memory pressure situations"}),"\n",(0,i.jsx)(n.li,{children:"Hot reload during development"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { clearAllCaches } from 'balda';\n\n// Clear during hot reload\nif (import.meta.hot) {\n  import.meta.hot.dispose(() => {\n    clearAllCaches();\n  });\n}\n\n// Clear in tests\nafterEach(() => {\n  clearAllCaches();\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"cache-invalidation-strategy",children:"Cache Invalidation Strategy"}),"\n",(0,i.jsx)(n.h3,{id:"current-strategy",children:"Current Strategy"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"No automatic invalidation"})," - Caches persist for the application lifetime."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Schema objects rarely change at runtime"}),"\n",(0,i.jsx)(n.li,{children:"Pre-compilation at startup provides optimal performance"}),"\n",(0,i.jsx)(n.li,{children:"WeakMap keys ensure garbage collection when schemas are unreferenced"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"when-caches-are-populated",children:"When Caches Are Populated"}),"\n",(0,i.jsx)(n.p,{children:"Caches are automatically populated during:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Route registration"})," - Eager compilation via ",(0,i.jsx)(n.code,{children:"router.addOrUpdate()"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decorator application"})," - When ",(0,i.jsx)(n.code,{children:"@serialize"})," or ",(0,i.jsx)(n.code,{children:"@validate"})," decorators are applied"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"First request"})," - Lazy compilation for dynamic routes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Swagger generation"})," - When OpenAPI spec is generated"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"cache-warming",children:"Cache Warming"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Best practice"}),": Pre-compile all schemas at startup for optimal performance."]}),"\n",(0,i.jsxs)(n.p,{children:["Schemas defined in route decorators and inline routes are ",(0,i.jsx)(n.strong,{children:"automatically pre-compiled"})," during route registration, ensuring the first request is fast."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { Server, controller, get, serialize } from 'balda';\nimport { z } from 'zod';\n\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n  email: z.string().email(),\n});\n\n@controller('/users')\nclass UserController {\n  // Schema is pre-compiled during controller registration\n  @get('/:id')\n  @serialize(UserSchema)\n  getUser() {\n    return { id: 1, name: 'John', email: 'john@example.com' };\n  }\n}\n\n// All schemas compiled during bootstrap\nconst server = new Server({ controllers: [UserController] });\nawait server.bootstrap();\nawait server.listen(3000);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"memory-considerations",children:"Memory Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"automatic-garbage-collection",children:"Automatic Garbage Collection"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Schema objects use ",(0,i.jsx)(n.strong,{children:"WeakMap-based keys"})]}),"\n",(0,i.jsx)(n.li,{children:"When a schema object is no longer referenced, its cache entry is automatically garbage collected"}),"\n",(0,i.jsx)(n.li,{children:"No manual cleanup needed for unreferenced schemas"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"long-running-processes",children:"Long-Running Processes"}),"\n",(0,i.jsx)(n.p,{children:"For applications with dynamic schema generation:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitor cache size"})," regularly using ",(0,i.jsx)(n.code,{children:"getCacheMetrics()"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Set up alerts"})," when memory exceeds thresholds"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consider manual clearing"})," if memory pressure is detected"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { getCacheMetrics, clearAllCaches, logger } from 'balda';\n\n// Monitor cache size every 5 minutes\nsetInterval(() => {\n  const metrics = getCacheMetrics();\n  const totalCacheSize = \n    metrics.validators.size + \n    metrics.serializers.size + \n    metrics.jsonSchemas.size;\n\n  if (totalCacheSize > 10000) {\n    logger.warn({ totalCacheSize }, 'Cache size exceeds threshold');\n    \n    // Consider clearing if memory pressure is critical\n    // clearAllCaches();\n  }\n}, 300000);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"memory-estimates",children:"Memory Estimates"}),"\n",(0,i.jsxs)(n.p,{children:["Cache metrics include ",(0,i.jsx)(n.strong,{children:"rough memory estimates"})," based on average sizes:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each validator: ~1-5KB"}),"\n",(0,i.jsx)(n.li,{children:"Each serializer: ~2-10KB"}),"\n",(0,i.jsx)(n.li,{children:"Each JSON schema: ~0.5-2KB"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Actual sizes vary based on schema complexity."}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsx)(n.h3,{id:"health-check-endpoints",children:"Health Check Endpoints"}),"\n",(0,i.jsx)(n.p,{children:"Expose cache metrics in health check endpoints:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { Server, controller, get, getCacheMetrics } from 'balda';\n\n@controller('/health')\nclass HealthController {\n  @get('/cache')\n  getCacheHealth() {\n    const metrics = getCacheMetrics();\n    \n    return {\n      status: 'healthy',\n      cache: {\n        validators: metrics.validators.size,\n        serializers: metrics.serializers.size,\n        jsonSchemas: metrics.jsonSchemas.size,\n        memory: metrics.memoryEstimate.total,\n      },\n      timestamp: Date.now(),\n    };\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"performance-monitoring-dashboards",children:"Performance Monitoring Dashboards"}),"\n",(0,i.jsx)(n.p,{children:"Integrate with monitoring tools like Prometheus, Grafana, or Datadog:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { getCacheMetrics } from 'balda';\nimport { register, Gauge } from 'prom-client';\n\n// Create Prometheus metrics\nconst cacheValidatorsGauge = new Gauge({\n  name: 'balda_cache_validators_total',\n  help: 'Total number of cached validators',\n});\n\nconst cacheSerializersGauge = new Gauge({\n  name: 'balda_cache_serializers_total',\n  help: 'Total number of cached serializers',\n});\n\nconst cacheMemoryGauge = new Gauge({\n  name: 'balda_cache_memory_kb',\n  help: 'Estimated cache memory usage in KB',\n});\n\n// Update metrics periodically\nsetInterval(() => {\n  const metrics = getCacheMetrics();\n  \n  cacheValidatorsGauge.set(metrics.validators.size);\n  cacheSerializersGauge.set(metrics.serializers.size);\n  \n  // Parse memory estimate (e.g., \"~1.2MB\" -> 1200)\n  const memoryMatch = metrics.memoryEstimate.total.match(/~([\\d.]+)(KB|MB)/);\n  if (memoryMatch) {\n    const value = parseFloat(memoryMatch[1]);\n    const unit = memoryMatch[2];\n    const kb = unit === 'MB' ? value * 1024 : value;\n    cacheMemoryGauge.set(kb);\n  }\n}, 15000);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"development-debugging",children:"Development Debugging"}),"\n",(0,i.jsx)(n.p,{children:"Log cache metrics during development to understand schema compilation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { Server, logCacheMetrics } from 'balda';\n\nconst server = new Server({\n  controllers: ['./controllers/**/*.ts'],\n});\n\nawait server.bootstrap();\n\n// Log cache metrics after all routes are registered\nif (process.env.NODE_ENV === 'development') {\n  logCacheMetrics();\n}\n\nawait server.listen(3000);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"testing-environments",children:"Testing Environments"}),"\n",(0,i.jsx)(n.p,{children:"Clear caches between tests to ensure isolation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { describe, it, beforeEach, afterEach } from 'vitest';\nimport { clearAllCaches, getCacheMetrics } from 'balda';\n\ndescribe('Cache tests', () => {\n  beforeEach(() => {\n    clearAllCaches();\n  });\n\n  it('should start with empty caches', () => {\n    const metrics = getCacheMetrics();\n    expect(metrics.validators.size).toBe(0);\n    expect(metrics.serializers.size).toBe(0);\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,i.jsx)(n.h3,{id:"cache-hit-vs-miss",children:"Cache Hit vs Miss"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cache Hit"})," (schema already compiled):"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Validator lookup: ~0.01ms"}),"\n",(0,i.jsx)(n.li,{children:"Serializer lookup: ~0.01ms"}),"\n",(0,i.jsx)(n.li,{children:"JSON Schema lookup: ~0.01ms"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cache Miss"})," (first compilation):"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Validator compilation: ~5-50ms (depending on schema complexity)"}),"\n",(0,i.jsx)(n.li,{children:"Serializer compilation: ~10-100ms (depending on schema complexity)"}),"\n",(0,i.jsx)(n.li,{children:"JSON Schema conversion: ~1-10ms (Zod to JSON Schema)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Recommendation"}),": Pre-compile all schemas at startup to avoid cache misses during requests."]}),"\n",(0,i.jsx)(n.h3,{id:"memory-vs-speed-trade-off",children:"Memory vs Speed Trade-off"}),"\n",(0,i.jsx)(n.p,{children:"Caching provides significant performance benefits with minimal memory overhead:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Speed gain"}),": 100-1000x faster (0.01ms vs 10-100ms)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory cost"}),": ~3-15KB per schema (all three caches combined)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For most applications, this is an excellent trade-off."}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitor in production"})," - Set up periodic cache metrics logging"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Alert on anomalies"})," - Create alerts for unusual cache growth"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pre-compile schemas"})," - Use route decorators for automatic pre-compilation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test cache behavior"})," - Verify schemas are cached as expected"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Profile memory usage"})," - Monitor ",(0,i.jsx)(n.code,{children:"memoryEstimate"})," in long-running processes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clear intentionally"})," - Only clear caches when necessary (testing, hot reload)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use structured logging"})," - Always use ",(0,i.jsx)(n.code,{children:"logCacheMetrics()"})," over manual console.log"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-apis",children:"Related APIs"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.a,{href:"/balda/docs/core-concepts/request-response",children:[(0,i.jsx)(n.code,{children:"@serialize"})," decorator"]})," - Automatic response serialization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.a,{href:"/balda/docs/core-concepts/request-response",children:[(0,i.jsx)(n.code,{children:"@validate"})," decorator"]})," - Request validation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/balda/docs/plugins/swagger",children:"Swagger Plugin"})," - OpenAPI documentation generation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/balda/docs/core-concepts/server",children:"Server Configuration"})," - Server setup and options"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var r=s(6540);const i={},c=r.createContext(i);function a(e){const n=r.useContext(c);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(c.Provider,{value:n},e.children)}}}]);