"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[682],{2442:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"examples/rest-api","title":"REST API Example","description":"A complete REST API example using Balda.js with validation, serialization, and error handling.","source":"@site/docs/examples/rest-api.md","sourceDirName":"examples","slug":"/examples/rest-api","permalink":"/balda-js/docs/examples/rest-api","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/balda-js/tree/main/docs/docs/examples/rest-api.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docs","previous":{"title":"Swagger Plugin","permalink":"/balda-js/docs/plugins/swagger"},"next":{"title":"Testing Overview","permalink":"/balda-js/docs/testing/overview"}}');var s=r(4848),o=r(8453);const a={sidebar_position:1},i="REST API Example",d={},c=[{value:"Project Structure",id:"project-structure",level:2},{value:"Server Setup",id:"server-setup",level:2},{value:"Data Schemas",id:"data-schemas",level:2},{value:"Services",id:"services",level:2},{value:"Middleware",id:"middleware",level:2},{value:"Controllers",id:"controllers",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"rest-api-example",children:"REST API Example"})}),"\n",(0,s.jsx)(n.p,{children:"A complete REST API example using Balda.js with validation, serialization, and error handling."}),"\n",(0,s.jsx)(n.h2,{id:"project-structure",children:"Project Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"src/\n\u251c\u2500\u2500 controllers/\n\u2502   \u251c\u2500\u2500 users.controller.ts\n\u2502   \u251c\u2500\u2500 posts.controller.ts\n\u2502   \u2514\u2500\u2500 auth.controller.ts\n\u251c\u2500\u2500 middleware/\n\u2502   \u251c\u2500\u2500 auth.middleware.ts\n\u2502   \u2514\u2500\u2500 validation.middleware.ts\n\u251c\u2500\u2500 schemas/\n\u2502   \u251c\u2500\u2500 user.schema.ts\n\u2502   \u2514\u2500\u2500 post.schema.ts\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 user.service.ts\n\u2502   \u2514\u2500\u2500 post.service.ts\n\u2514\u2500\u2500 server.ts\n"})}),"\n",(0,s.jsx)(n.h2,{id:"server-setup",children:"Server Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/server.ts\nimport { Server } from 'balda-js';\n\nconst server = new Server({\n  port: 3000,\n  host: 'localhost',\n  controllerPatterns: ['./src/controllers/**/*.ts'],\n  plugins: {\n    cors: {\n      origin: ['http://localhost:3000', 'http://localhost:3001'],\n      credentials: true\n    },\n    json: {\n      sizeLimit: '10mb',\n      strict: true\n    },\n    cookie: {\n      secret: process.env.COOKIE_SECRET || 'dev-secret',\n      secure: false,\n      httpOnly: true\n    },\n    helmet: {\n      contentSecurityPolicy: false\n    },\n    log: {\n      logRequest: true,\n      logResponse: true\n    }\n  },\n  swagger: {\n    type: 'standard',\n    models: {\n      User: {\n        type: 'object',\n        properties: {\n          id: { type: 'number' },\n          email: { type: 'string' },\n          name: { type: 'string' },\n          createdAt: { type: 'string', format: 'date-time' }\n        }\n      },\n      Post: {\n        type: 'object',\n        properties: {\n          id: { type: 'number' },\n          title: { type: 'string' },\n          content: { type: 'string' },\n          authorId: { type: 'number' },\n          createdAt: { type: 'string', format: 'date-time' }\n        }\n      }\n    }\n  }\n});\n\n// Global error handler\nserver.setErrorHandler((req, res, next, error) => {\n  console.error('Error:', error);\n\n  if (error.name === 'ValidationError') {\n    return res.badRequest({\n      error: 'Validation failed',\n      details: error.message\n    });\n  }\n\n  if (error.name === 'UnauthorizedError') {\n    return res.unauthorized({ error: 'Authentication required' });\n  }\n\n  res.internalServerError({ error: 'Internal server error' });\n});\n\nserver.listen(({ port, host }) => {\n  console.log(`\ud83d\ude80 Server running on http://${host}:${port}`);\n  console.log(`\ud83d\udcda API Documentation: http://${host}:${port}/docs`);\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"data-schemas",children:"Data Schemas"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/schemas/user.schema.ts\nimport { Type } from '@sinclair/typebox';\n\nexport const CreateUserSchema = Type.Object({\n  email: Type.String({ format: 'email' }),\n  password: Type.String({ minLength: 8 }),\n  name: Type.String({ minLength: 1, maxLength: 100 })\n});\n\nexport const UpdateUserSchema = Type.Partial(CreateUserSchema);\n\nexport const UserSchema = Type.Object({\n  id: Type.Number(),\n  email: Type.String({ format: 'email' }),\n  name: Type.String(),\n  createdAt: Type.String({ format: 'date-time' }),\n  updatedAt: Type.String({ format: 'date-time' })\n});\n\nexport const LoginSchema = Type.Object({\n  email: Type.String({ format: 'email' }),\n  password: Type.String()\n});\n\nexport type CreateUser = Static<typeof CreateUserSchema>;\nexport type UpdateUser = Static<typeof UpdateUserSchema>;\nexport type User = Static<typeof UserSchema>;\nexport type Login = Static<typeof LoginSchema>;\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/schemas/post.schema.ts\nimport { Type } from '@sinclair/typebox';\n\nexport const CreatePostSchema = Type.Object({\n  title: Type.String({ minLength: 1, maxLength: 200 }),\n  content: Type.String({ minLength: 1 }),\n  published: Type.Optional(Type.Boolean())\n});\n\nexport const UpdatePostSchema = Type.Partial(CreatePostSchema);\n\nexport const PostSchema = Type.Object({\n  id: Type.Number(),\n  title: Type.String(),\n  content: Type.String(),\n  published: Type.Boolean(),\n  authorId: Type.Number(),\n  createdAt: Type.String({ format: 'date-time' }),\n  updatedAt: Type.String({ format: 'date-time' })\n});\n\nexport type CreatePost = Static<typeof CreatePostSchema>;\nexport type UpdatePost = Static<typeof UpdatePostSchema>;\nexport type Post = Static<typeof PostSchema>;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"services",children:"Services"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/services/user.service.ts\nimport { User, CreateUser, UpdateUser } from '../schemas/user.schema';\n\nexport class UserService {\n  private users: User[] = [];\n  private nextId = 1;\n\n  async findAll(): Promise<User[]> {\n    return this.users;\n  }\n\n  async findById(id: number): Promise<User | null> {\n    return this.users.find(user => user.id === id) || null;\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    return this.users.find(user => user.email === email) || null;\n  }\n\n  async create(data: CreateUser): Promise<User> {\n    const existingUser = await this.findByEmail(data.email);\n    if (existingUser) {\n      throw new Error('User with this email already exists');\n    }\n\n    const user: User = {\n      id: this.nextId++,\n      email: data.email,\n      name: data.name,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n\n    this.users.push(user);\n    return user;\n  }\n\n  async update(id: number, data: UpdateUser): Promise<User | null> {\n    const userIndex = this.users.findIndex(user => user.id === id);\n    if (userIndex === -1) {\n      return null;\n    }\n\n    const updatedUser = {\n      ...this.users[userIndex],\n      ...data,\n      updatedAt: new Date().toISOString()\n    };\n\n    this.users[userIndex] = updatedUser;\n    return updatedUser;\n  }\n\n  async delete(id: number): Promise<boolean> {\n    const userIndex = this.users.findIndex(user => user.id === id);\n    if (userIndex === -1) {\n      return false;\n    }\n\n    this.users.splice(userIndex, 1);\n    return true;\n  }\n}\n\nexport const userService = new UserService();\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/services/post.service.ts\nimport { Post, CreatePost, UpdatePost } from '../schemas/post.schema';\n\nexport class PostService {\n  private posts: Post[] = [];\n  private nextId = 1;\n\n  async findAll(published?: boolean): Promise<Post[]> {\n    if (published !== undefined) {\n      return this.posts.filter(post => post.published === published);\n    }\n    return this.posts;\n  }\n\n  async findById(id: number): Promise<Post | null> {\n    return this.posts.find(post => post.id === id) || null;\n  }\n\n  async findByAuthor(authorId: number): Promise<Post[]> {\n    return this.posts.filter(post => post.authorId === authorId);\n  }\n\n  async create(data: CreatePost, authorId: number): Promise<Post> {\n    const post: Post = {\n      id: this.nextId++,\n      title: data.title,\n      content: data.content,\n      published: data.published || false,\n      authorId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n\n    this.posts.push(post);\n    return post;\n  }\n\n  async update(id: number, data: UpdatePost): Promise<Post | null> {\n    const postIndex = this.posts.findIndex(post => post.id === id);\n    if (postIndex === -1) {\n      return null;\n    }\n\n    const updatedPost = {\n      ...this.posts[postIndex],\n      ...data,\n      updatedAt: new Date().toISOString()\n    };\n\n    this.posts[postIndex] = updatedPost;\n    return updatedPost;\n  }\n\n  async delete(id: number): Promise<boolean> {\n    const postIndex = this.posts.findIndex(post => post.id === id);\n    if (postIndex === -1) {\n      return false;\n    }\n\n    this.posts.splice(postIndex, 1);\n    return true;\n  }\n}\n\nexport const postService = new PostService();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"middleware",children:"Middleware"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/middleware/auth.middleware.ts\nimport { Request, Response, NextFunction } from 'balda-js';\nimport { userService } from '../services/user.service';\n\nexport const authMiddleware = async (req: Request, res: Response, next: NextFunction) => {\n  const token = req.headers.authorization?.replace('Bearer ', '');\n\n  if (!token) {\n    return res.unauthorized({ error: 'Authentication token required' });\n  }\n\n  try {\n    // In a real app, you'd verify the JWT token here\n    // For this example, we'll use a simple user ID lookup\n    const userId = parseInt(token);\n    const user = await userService.findById(userId);\n\n    if (!user) {\n      return res.unauthorized({ error: 'Invalid authentication token' });\n    }\n\n    req.user = user;\n    next();\n  } catch (error) {\n    return res.unauthorized({ error: 'Invalid authentication token' });\n  }\n};\n\nexport const optionalAuthMiddleware = async (req: Request, res: Response, next: NextFunction) => {\n  const token = req.headers.authorization?.replace('Bearer ', '');\n\n  if (token) {\n    try {\n      const userId = parseInt(token);\n      const user = await userService.findById(userId);\n      if (user) {\n        req.user = user;\n      }\n    } catch (error) {\n      // Ignore auth errors for optional auth\n    }\n  }\n\n  next();\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"controllers",children:"Controllers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/controllers/users.controller.ts\nimport {\n  controller,\n  get,\n  post,\n  put,\n  del,\n  validate,\n  serialize,\n  middleware\n} from 'balda-js';\nimport { Request, Response } from 'balda-js';\nimport {\n  CreateUserSchema,\n  UpdateUserSchema,\n  UserSchema,\n  LoginSchema\n} from '../schemas/user.schema';\nimport { userService } from '../services/user.service';\nimport { authMiddleware } from '../middleware/auth.middleware';\n\n@controller('/users')\nexport class UsersController {\n  @get('/')\n  @serialize(Type.Array(UserSchema))\n  async getAllUsers(req: Request, res: Response) {\n    const users = await userService.findAll();\n    res.json(users);\n  }\n\n  @get('/:id')\n  @serialize(UserSchema)\n  async getUserById(req: Request, res: Response) {\n    const id = parseInt(req.params.id);\n    const user = await userService.findById(id);\n\n    if (!user) {\n      return res.notFound({ error: 'User not found' });\n    }\n\n    res.json(user);\n  }\n\n  @post('/')\n  @validate.body(CreateUserSchema)\n  @serialize(UserSchema)\n  async createUser(req: Request, res: Response, body: CreateUser) {\n    try {\n      const user = await userService.create(body);\n      res.created(user);\n    } catch (error) {\n      return res.conflict({ error: error.message });\n    }\n  }\n\n  @put('/:id')\n  @middleware(authMiddleware)\n  @validate.body(UpdateUserSchema)\n  @serialize(UserSchema)\n  async updateUser(req: Request, res: Response, body: UpdateUser) {\n    const id = parseInt(req.params.id);\n\n    // Ensure users can only update their own profile\n    if (req.user.id !== id) {\n      return res.forbidden({ error: 'Cannot update other users' });\n    }\n\n    const user = await userService.update(id, body);\n\n    if (!user) {\n      return res.notFound({ error: 'User not found' });\n    }\n\n    res.json(user);\n  }\n\n  @del('/:id')\n  @middleware(authMiddleware)\n  async deleteUser(req: Request, res: Response) {\n    const id = parseInt(req.params.id);\n\n    // Ensure users can only delete their own account\n    if (req.user.id !== id) {\n      return res.forbidden({ error: 'Cannot delete other users' });\n    }\n\n    const deleted = await userService.delete(id);\n\n    if (!deleted) {\n      return res.notFound({ error: 'User not found' });\n    }\n\n    res.noContent();\n  }\n\n  @post('/login')\n  @validate.body(LoginSchema)\n  async login(req: Request, res: Response, body: Login) {\n    const user = await userService.findByEmail(body.email);\n\n    if (!user) {\n      return res.unauthorized({ error: 'Invalid credentials' });\n    }\n\n    // In a real app, you'd verify the password hash here\n    // For this example, we'll just return the user ID as a token\n    res.json({\n      token: user.id.toString(),\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/controllers/posts.controller.ts\nimport {\n  controller,\n  get,\n  post,\n  put,\n  del,\n  validate,\n  serialize,\n  middleware,\n  Request,\n  Response\n} from 'balda-js';\nimport { Type, Static } from '@sinclair/typebox';\nimport {\n  CreatePostSchema,\n  UpdatePostSchema,\n  PostSchema\n} from '../schemas/post.schema';\nimport { postService } from '../services/post.service';\nimport { authMiddleware, optionalAuthMiddleware } from '../middleware/auth.middleware';\n\n@controller('/posts')\nexport class PostsController {\n  @get('/')\n  @middleware(optionalAuthMiddleware)\n  @serialize(Type.Array(PostSchema))\n  async getAllPosts(req: Request, res: Response) {\n    const published = req.query.published === 'true';\n    const posts = await postService.findAll(published);\n    res.json(posts);\n  }\n\n  @get('/:id')\n  @serialize(PostSchema)\n  async getPostById(req: Request, res: Response) {\n    const id = parseInt(req.params.id);\n    const post = await postService.findById(id);\n\n    if (!post) {\n      return res.notFound({ error: 'Post not found' });\n    }\n\n    // Only show unpublished posts to their authors\n    if (!post.published && (!req.user || req.user.id !== post.authorId)) {\n      return res.notFound({ error: 'Post not found' });\n    }\n\n    res.json(post);\n  }\n\n  @post('/')\n  @middleware(authMiddleware)\n  @validate.body(CreatePostSchema)\n  @serialize(PostSchema)\n  async createPost(req: Request, res: Response, body: Static<CreatePostSchema>) {\n    const post = await postService.create(body, req.user.id);\n    res.created(post);\n  }\n\n  @put('/:id')\n  @middleware(authMiddleware)\n  @validate.body(UpdatePostSchema)\n  @serialize(PostSchema)\n  async updatePost(req: Request, res: Response, body: UpdatePost) {\n    const id = parseInt(req.params.id);\n    const existingPost = await postService.findById(id);\n\n    if (!existingPost) {\n      return res.notFound({ error: 'Post not found' });\n    }\n\n    // Ensure users can only update their own posts\n    if (req.user.id !== existingPost.authorId) {\n      return res.forbidden({ error: 'Cannot update other users\\' posts' });\n    }\n\n    const post = await postService.update(id, body);\n    res.json(post);\n  }\n\n  @del('/:id')\n  @middleware(authMiddleware)\n  async deletePost(req: Request, res: Response) {\n    const id = parseInt(req.params.id);\n    const existingPost = await postService.findById(id);\n\n    if (!existingPost) {\n      return res.notFound({ error: 'Post not found' });\n    }\n\n    // Ensure users can only delete their own posts\n    if (req.user.id !== existingPost.authorId) {\n      return res.forbidden({ error: 'Cannot delete other users\\' posts' });\n    }\n\n    const deleted = await postService.delete(id);\n    res.noContent();\n  }\n\n  @get('/author/:authorId')\n  @serialize(Type.Array(PostSchema))\n  async getPostsByAuthor(req: Request, res: Response) {\n    const authorId = parseInt(req.params.authorId);\n    const posts = await postService.findByAuthor(authorId);\n\n    // Filter out unpublished posts unless the user is the author\n    const filteredPosts = posts.filter(post =>\n      post.published || (req.user && req.user.id === authorId)\n    );\n\n    res.json(filteredPosts);\n  }\n}\n"})})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var t=r(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);