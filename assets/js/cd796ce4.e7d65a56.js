"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8716],{8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>u});var i=n(6540);const t={},r=i.createContext(t);function a(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function u(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:s},e.children)}},8943:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>u,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"queues/publishing","title":"publishing","description":"Publishing","source":"@site/docs/queues/publishing.md","sourceDirName":"queues","slug":"/queues/publishing","permalink":"/balda/docs/queues/publishing","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/balda/tree/main/docs/docs/queues/publishing.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docs","previous":{"title":"overview","permalink":"/balda/docs/queues/overview"},"next":{"title":"providers","permalink":"/balda/docs/queues/providers"}}');var t=n(4848),r=n(8453);const a={sidebar_position:2},u=void 0,o={},l=[{value:"Publishing",id:"publishing",level:3},{value:"Best Practice: Centralized Queue Registry",id:"best-practice-centralized-queue-registry",level:4},{value:"Creating typed queues",id:"creating-typed-queues",level:4},{value:"Basic publishing",id:"basic-publishing",level:4},{value:"Publishing with provider options",id:"publishing-with-provider-options",level:4},{value:"Subscribing to queues",id:"subscribing-to-queues",level:4},{value:"Type safety benefits",id:"type-safety-benefits",level:4},{value:"Multiple queues with the same provider",id:"multiple-queues-with-the-same-provider",level:4},{value:"Summary: Two ways to subscribe",id:"summary-two-ways-to-subscribe",level:4}];function c(e){const s={code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h3,{id:"publishing",children:"Publishing"}),"\n",(0,t.jsxs)(s.p,{children:["Use typed queue instances to publish jobs with full type safety. Each queue instance has a ",(0,t.jsx)(s.code,{children:"publish"})," method that accepts the payload and optional provider-specific options."]}),"\n",(0,t.jsx)(s.h4,{id:"best-practice-centralized-queue-registry",children:"Best Practice: Centralized Queue Registry"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Recommended (but not enforced):"})," Define all queues in a centralized location for better organization and reusability:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"// src/queues/registry.ts\nimport { bullmqQueue, sqsQueue, pgbossQueue } from 'balda';\n\n// Define payload types\ntype UserEvent = { userId: string; action: string };\ntype EmailJob = { to: string; subject: string; body: string };\ntype NotificationJob = { userId: string; message: string };\n\n// Export all queues from a single registry\nexport const queues = {\n  userEvents: bullmqQueue<UserEvent>('user-events'),\n  emails: sqsQueue<EmailJob>('emails', {\n    queueUrl: 'https://sqs.us-east-1.amazonaws.com/123456789/emails'\n  }),\n  notifications: pgbossQueue<NotificationJob>('notifications'),\n} as const;\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Single source of truth for all queues"}),"\n",(0,t.jsxs)(s.li,{children:["Easy to import: ",(0,t.jsx)(s.code,{children:"import { queues } from './queues/registry.js'"})]}),"\n",(0,t.jsx)(s.li,{children:"Consistent queue configuration across the application"}),"\n",(0,t.jsx)(s.li,{children:"Better discoverability of available queues"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Usage:"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"import { queues } from './queues/registry.js';\n\n// Publishing\nawait queues.userEvents.publish({ userId: '123', action: 'signup' });\nawait queues.emails.publish({ to: 'user@example.com', subject: 'Welcome', body: 'Hello!' });\n\n// Subscribing\nexport class UserEventHandler {\n  @queues.userEvents.subscribe()\n  async handle(payload: UserEvent) {\n    console.log(`User ${payload.userId} performed ${payload.action}`);\n  }\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"This pattern is completely optional - you can also define queues inline or in separate files based on your preference."}),"\n",(0,t.jsx)(s.h4,{id:"creating-typed-queues",children:"Creating typed queues"}),"\n",(0,t.jsx)(s.p,{children:"Alternatively, create typed queue instances directly where needed using factory functions:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"import { bullmqQueue, sqsQueue, pgbossQueue } from 'balda';\n\n// Define payload types\ntype UserEvent = { userId: string; action: string };\ntype EmailJob = { to: string; subject: string; body: string };\ntype NotificationJob = { userId: string; message: string };\n\n// Create queue instances\nexport const userQueue = bullmqQueue<UserEvent>('user-events');\nexport const emailQueue = sqsQueue<EmailJob>('emails', {\n  queueUrl: 'https://sqs.us-east-1.amazonaws.com/123456789/emails'\n});\nexport const notificationQueue = pgbossQueue<NotificationJob>('notifications');\n"})}),"\n",(0,t.jsx)(s.h4,{id:"basic-publishing",children:"Basic publishing"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"// Publish to BullMQ\nawait userQueue.publish({ userId: '123', action: 'signup' });\n\n// Publish to SQS\nawait emailQueue.publish({\n  to: 'user@example.com',\n  subject: 'Welcome',\n  body: 'Thanks for signing up!'\n});\n\n// Publish to PGBoss\nawait notificationQueue.publish({\n  userId: '123',\n  message: 'Your order has shipped'\n});\n"})}),"\n",(0,t.jsx)(s.h4,{id:"publishing-with-provider-options",children:"Publishing with provider options"}),"\n",(0,t.jsx)(s.p,{children:"Each provider supports specific options as the second parameter:"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"BullMQ options"})," (maps to ",(0,t.jsx)(s.code,{children:"Queue.add"})," third parameter):"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"await userQueue.publish(\n  { userId: '123', action: 'signup' },\n  {\n    delay: 5000,                    // Delay 5 seconds\n    priority: 1,                     // High priority\n    removeOnComplete: true,          // Auto-remove on completion\n    attempts: 3,                     // Retry up to 3 times\n    backoff: {\n      type: 'exponential',\n      delay: 2000\n    }\n  }\n);\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"SQS options"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"await emailQueue.publish(\n  { to: 'user@example.com', subject: 'Hello', body: 'World' },\n  {\n    MessageGroupId: 'emails',        // For FIFO queues\n    MessageDeduplicationId: '123',   // For FIFO queues\n    DelaySeconds: 10,                // Delay 10 seconds\n    MessageAttributes: {             // Custom attributes\n      priority: {\n        DataType: 'String',\n        StringValue: 'high'\n      }\n    }\n  }\n);\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"PGBoss options"})," (maps to ",(0,t.jsx)(s.code,{children:"send"})," third parameter):"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"await notificationQueue.publish(\n  { userId: '123', message: 'Hello!' },\n  {\n    retryLimit: 3,                   // Retry up to 3 times\n    retryDelay: 60,                  // Wait 60 seconds between retries\n    expireInSeconds: 3600,           // Expire after 1 hour\n    priority: 10                     // Higher number = higher priority\n  }\n);\n"})}),"\n",(0,t.jsx)(s.h4,{id:"subscribing-to-queues",children:"Subscribing to queues"}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"subscribe"})," method supports two patterns:"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"1. Decorator-based subscription (recommended for class methods):"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"export class UserEventHandler {\n  @userQueue.subscribe()\n  async handle(payload: UserEvent) {\n    console.log(`User ${payload.userId} performed ${payload.action}`);\n  }\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"2. Callback-based subscription (recommended for standalone functions):"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"await userQueue.subscribe(async (payload) => {\n  console.log(`User ${payload.userId} performed ${payload.action}`);\n});\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Key differences:"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Decorators"})," are ideal for organized class-based handlers and work seamlessly with dependency injection patterns"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Callbacks"})," are perfect for simple handlers, scripts, or when you prefer a functional programming style"]}),"\n",(0,t.jsx)(s.li,{children:"Both methods provide full type safety and identical runtime behavior"}),"\n",(0,t.jsx)(s.li,{children:"You can mix both approaches in the same application"}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"type-safety-benefits",children:"Type safety benefits"}),"\n",(0,t.jsx)(s.p,{children:"The typed queue API provides full type safety:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"// \u2705 Type-safe: correct payload\nawait userQueue.publish({ userId: '123', action: 'signup' });\n\n// \u274c TypeScript error: missing required fields\nawait userQueue.publish({ userId: '123' });\n\n// \u274c TypeScript error: wrong field type\nawait userQueue.publish({ userId: 123, action: 'signup' });\n\n// \u2705 Type-safe handler\n@userQueue.subscribe()\nasync handle(payload: UserEvent) {\n  // payload.userId is string\n  // payload.action is string\n  // Full autocomplete and type checking\n}\n"})}),"\n",(0,t.jsx)(s.h4,{id:"multiple-queues-with-the-same-provider",children:"Multiple queues with the same provider"}),"\n",(0,t.jsx)(s.p,{children:"You can create multiple queue instances for the same provider:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"import { bullmqQueue } from 'balda';\n\n// Different queues for different job types\nexport const emailQueue = bullmqQueue<EmailJob>('emails');\nexport const smsQueue = bullmqQueue<SMSJob>('sms');\nexport const pushQueue = bullmqQueue<PushJob>('push-notifications');\n\n// Each has its own type-safe publish/subscribe\nawait emailQueue.publish({ to: 'user@example.com', ... });\nawait smsQueue.publish({ phone: '+1234567890', ... });\nawait pushQueue.publish({ deviceToken: 'abc123', ... });\n"})}),"\n",(0,t.jsx)(s.h4,{id:"summary-two-ways-to-subscribe",children:"Summary: Two ways to subscribe"}),"\n",(0,t.jsx)(s.p,{children:"Every typed queue instance (BullMQ, SQS, PGBoss, or custom) supports both subscription methods:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"import { bullmqQueue, sqsQueue, pgbossQueue } from 'balda';\n\nconst queue = bullmqQueue<MyPayload>('my-topic');\n\n// Method 1: Decorator (for class methods)\nclass MyHandler {\n  @queue.subscribe()\n  async handle(payload: MyPayload) { }\n}\n\n// Method 2: Callback (for standalone functions)\nawait queue.subscribe(async (payload) => { });\n"})}),"\n",(0,t.jsx)(s.p,{children:"Choose the method that best fits your application architecture. Both provide identical functionality and full TypeScript type safety."})]})}function d(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);