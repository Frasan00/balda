"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1806],{8453:(e,a,n)=>{n.d(a,{R:()=>c,x:()=>r});var t=n(6540);const s={},i=t.createContext(s);function c(e){const a=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(i.Provider,{value:a},e.children)}},9992:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"cache/invalidation","title":"Invalidation","description":"Balda provides three invalidation strategies: tag-based, key-based, and pattern-based. All are available via server.cache, which is a typed CacheService property on the server instance.","source":"@site/docs/cache/invalidation.md","sourceDirName":"cache","slug":"/cache/invalidation","permalink":"/balda/docs/cache/invalidation","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/balda/tree/main/docs/docs/cache/invalidation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docs","previous":{"title":"Cache Keys","permalink":"/balda/docs/cache/cache-keys"},"next":{"title":"Advanced","permalink":"/balda/docs/cache/advanced"}}');var s=n(4848),i=n(8453);const c={sidebar_position:4},r="Invalidation",d={},o=[{value:"Accessing <code>server.cache</code>",id:"accessing-servercache",level:2},{value:"Tag-Based Invalidation",id:"tag-based-invalidation",level:2},{value:"Key-Based Invalidation",id:"key-based-invalidation",level:2},{value:"Pattern-Based Invalidation",id:"pattern-based-invalidation",level:2},{value:"Manual <code>get</code> / <code>set</code>",id:"manual-get--set",level:2},{value:"Invalidation in Route Handlers",id:"invalidation-in-route-handlers",level:2}];function l(e){const a={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.header,{children:(0,s.jsx)(a.h1,{id:"invalidation",children:"Invalidation"})}),"\n",(0,s.jsxs)(a.p,{children:["Balda provides three invalidation strategies: ",(0,s.jsx)(a.strong,{children:"tag-based"}),", ",(0,s.jsx)(a.strong,{children:"key-based"}),", and ",(0,s.jsx)(a.strong,{children:"pattern-based"}),". All are available via ",(0,s.jsx)(a.code,{children:"server.cache"}),", which is a typed ",(0,s.jsx)(a.code,{children:"CacheService"})," property on the server instance."]}),"\n",(0,s.jsx)(a.admonition,{type:"warning",children:(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.code,{children:"server.cache"})," throws if the ",(0,s.jsx)(a.code,{children:"cache"})," option was not configured in ",(0,s.jsx)(a.code,{children:"ServerOptions"}),". Always configure it first."]})}),"\n",(0,s.jsxs)(a.h2,{id:"accessing-servercache",children:["Accessing ",(0,s.jsx)(a.code,{children:"server.cache"})]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",children:"import { Server } from 'balda';\n\nconst server = new Server({\n  cache: { provider: 'memory' },\n});\n\nawait server.listen();\n\n// server.cache is typed as CacheService\nawait server.cache.invalidate(['products']);\n"})}),"\n",(0,s.jsxs)(a.p,{children:["You can also access the global cache service singleton after initialisation using ",(0,s.jsx)(a.code,{children:"getCacheService()"})," \u2014 this is useful inside route handlers or services that don't have a direct reference to the server instance:"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",children:"import { getCacheService } from 'balda';\n\nconst cacheService = getCacheService(); // CacheService | null\nawait cacheService?.invalidate(['products']);\n"})}),"\n",(0,s.jsx)(a.h2,{id:"tag-based-invalidation",children:"Tag-Based Invalidation"}),"\n",(0,s.jsx)(a.p,{children:"Tags let you group related cache entries and invalidate them together. Assign tags in the cache config:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",children:"// Decorator\n@get('/products')\n@cache({ ttl: 120, tags: ['products'] })\nasync listProducts(_req, res) { /* ... */ }\n\n@get('/products/:id')\n@cache({ ttl: 120, tags: ['products'] })\nasync getProduct(req, res) { /* ... */ }\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Then invalidate all entries tagged ",(0,s.jsx)(a.code,{children:"'products'"})," in one call:"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",children:"// e.g. after a product is updated\nawait server.cache.invalidate(['products']);\n"})}),"\n",(0,s.jsx)(a.p,{children:"Multiple tags can be invalidated at once:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",children:"await server.cache.invalidate(['products', 'categories']);\n"})}),"\n",(0,s.jsx)(a.admonition,{type:"info",children:(0,s.jsx)(a.p,{children:"Internally, each tag maps to a Redis set (or in-memory set) that stores all cache keys sharing that tag. Invalidation deletes those keys and the tag set itself."})}),"\n",(0,s.jsx)(a.h2,{id:"key-based-invalidation",children:"Key-Based Invalidation"}),"\n",(0,s.jsx)(a.p,{children:"Delete a single known cache key:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",children:"await server.cache.invalidateKey('cache:GET:/api/products::abc123');\n"})}),"\n",(0,s.jsxs)(a.p,{children:["This returns ",(0,s.jsx)(a.code,{children:"true"})," if the key existed and was deleted, ",(0,s.jsx)(a.code,{children:"false"})," otherwise."]}),"\n",(0,s.jsx)(a.h2,{id:"pattern-based-invalidation",children:"Pattern-Based Invalidation"}),"\n",(0,s.jsx)(a.p,{children:"Delete all keys matching a glob pattern. Useful when you know the route prefix but not the exact key hashes:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",children:"// Invalidate all cached GET /api/products/** entries\nawait server.cache.invalidatePattern('cache:GET:/api/products*');\n\n// Wipe everything under the default prefix\nawait server.cache.invalidatePattern('cache:*');\n"})}),"\n",(0,s.jsx)(a.p,{children:"Returns the total number of keys deleted."}),"\n",(0,s.jsxs)(a.h2,{id:"manual-get--set",children:["Manual ",(0,s.jsx)(a.code,{children:"get"})," / ",(0,s.jsx)(a.code,{children:"set"})]}),"\n",(0,s.jsxs)(a.p,{children:["The cache service also exposes low-level ",(0,s.jsx)(a.code,{children:"get"})," and ",(0,s.jsx)(a.code,{children:"set"})," methods for custom caching logic outside of route middleware:"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",children:"// Read from cache\nconst cached = await server.cache.get<User[]>('my-custom-key');\n\nif (!cached) {\n  const data = await db.users.findAll();\n\n  // Store with a 60-second TTL, tagged for later invalidation\n  await server.cache.set('my-custom-key', data, 60, { tags: ['users'] });\n}\n"})}),"\n",(0,s.jsx)(a.h2,{id:"invalidation-in-route-handlers",children:"Invalidation in Route Handlers"}),"\n",(0,s.jsx)(a.p,{children:"A common pattern is to invalidate cache entries when data changes:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",children:"import { controller, post, put, del } from 'balda';\nimport { getCacheService } from 'balda';\n\n@controller('/api/products')\nclass ProductController {\n  @post('/')\n  async create(req, res) {\n    const product = await db.products.create(req.body);\n    await getCacheService()?.invalidate(['products']);\n    res.status(201).json(product);\n  }\n\n  @put('/:id')\n  async update(req, res) {\n    const product = await db.products.update(req.params.id, req.body);\n    await getCacheService()?.invalidate(['products']);\n    res.json(product);\n  }\n\n  @del('/:id')\n  async remove(req, res) {\n    await db.products.delete(req.params.id);\n    await getCacheService()?.invalidate(['products']);\n    res.status(204).send();\n  }\n}\n"})})]})}function h(e={}){const{wrapper:a}={...(0,i.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);