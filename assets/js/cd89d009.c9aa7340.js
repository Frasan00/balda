"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2322],{2659:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"core-concepts/policies","title":"Policies","description":"The Policy system in Balda provides a flexible, type-safe way to implement authorization and access control. Policies are organized by scope and allow you to define reusable authorization handlers that can be used throughout your application.","source":"@site/docs/core-concepts/policies.md","sourceDirName":"core-concepts","slug":"/core-concepts/policies","permalink":"/balda/docs/core-concepts/policies","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/balda/tree/main/docs/docs/core-concepts/policies.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"docs","previous":{"title":"Logger","permalink":"/balda/docs/core-concepts/logger"},"next":{"title":"Error Handling","permalink":"/balda/docs/core-concepts/error-handling"}}');var i=s(4848),c=s(8453);const o={sidebar_position:6},a="Policies",t={},l=[{value:"Overview",id:"overview",level:2},{value:"Basic Concepts",id:"basic-concepts",level:2},{value:"Policy Provider",id:"policy-provider",level:3},{value:"Policy Manager",id:"policy-manager",level:3},{value:"Creating a Policy Manager",id:"creating-a-policy-manager",level:2},{value:"Using the Policy Manager",id:"using-the-policy-manager",level:2},{value:"Checking Access",id:"checking-access",level:3},{value:"Policy Decorator",id:"policy-decorator",level:2},{value:"Creating a Decorator",id:"creating-a-decorator",level:3},{value:"Class-Level Policies",id:"class-level-policies",level:3},{value:"Method-Level Policies",id:"method-level-policies",level:3},{value:"Combining Class and Method Policies",id:"combining-class-and-method-policies",level:3},{value:"Controller Example",id:"controller-example",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"policies",children:"Policies"})}),"\n",(0,i.jsx)(n.p,{children:"The Policy system in Balda provides a flexible, type-safe way to implement authorization and access control. Policies are organized by scope and allow you to define reusable authorization handlers that can be used throughout your application."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:["The Policy system uses a ",(0,i.jsx)(n.code,{children:"PolicyManager"})," class that manages multiple policy providers organized by scope. Each scope contains multiple handlers that determine whether a user or entity has access to perform specific actions."]}),"\n",(0,i.jsx)(n.h2,{id:"basic-concepts",children:"Basic Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"policy-provider",children:"Policy Provider"}),"\n",(0,i.jsxs)(n.p,{children:["A policy provider is an object that contains multiple authorization handlers. Each handler is a function that takes any arguments and returns a boolean or ",(0,i.jsx)(n.code,{children:"Promise<boolean>"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"type PolicyProvider = {\n  [K: string]: (...args: any[]) => Promise<boolean> | boolean;\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"policy-manager",children:"Policy Manager"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"PolicyManager"})," class manages multiple policy providers, each organized under a scope name. It provides a type-safe ",(0,i.jsx)(n.code,{children:"canAccess"})," method to check permissions."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-policy-manager",children:"Creating a Policy Manager"}),"\n",(0,i.jsx)(n.p,{children:"You can define multiple scopes, each with their own handlers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const policyManager = new PolicyManager({\n  users: {\n    adminRoute: async (user: { id: string; role: string }) => {\n      return user.role === 'admin';\n    },\n    canView: async (user: { id: string; role: string }, targetUserId: string) => {\n      return user.id === targetUserId || user.role === 'admin';\n    },\n    canEdit: async (user: { id: string; role: string }, targetUserId: string) => {\n      return user.id === targetUserId || user.role === 'admin';\n    },\n    canDelete: async (user: { id: string; role: string }) => {\n      return user.role === 'admin';\n    },\n  },\n  documents: {\n    canView: async (user: { id: string; role: string }, document: { id: string; ownerId: string; isPublic: boolean }) => {\n      if (document.isPublic) {\n        return true;\n      }\n      return document.ownerId === user.id || user.role === 'admin';\n    },\n    canEdit: async (user: { id: string; role: string }, document: { id: string; ownerId: string }) => {\n      return document.ownerId === user.id || user.role === 'admin';\n    },\n    canDelete: async (user: { id: string; role: string }, document: { id: string; ownerId: string }) => {\n      return document.ownerId === user.id || user.role === 'admin';\n    },\n    canShare: async (user: { id: string; role: string }, document: { id: string; ownerId: string }) => {\n      return document.ownerId === user.id || user.role === 'admin';\n    },\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"using-the-policy-manager",children:"Using the Policy Manager"}),"\n",(0,i.jsx)(n.h3,{id:"checking-access",children:"Checking Access"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"canAccess"})," method to check if a user has permission to perform an action:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const user = { id: '1', name: 'John', role: 'admin' };\n\n// Check if user can access admin route\nconst hasAccess = await policyManager.canAccess('test', 'adminRoute', user); // type safe\nif (hasAccess) {\n  // User has access\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"policy-decorator",children:"Policy Decorator"}),"\n",(0,i.jsx)(n.p,{children:"The policy decorator provides a declarative way to attach policy metadata to controllers and route handlers. This allows you to define authorization requirements directly on your classes and methods."}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-decorator",children:"Creating a Decorator"}),"\n",(0,i.jsxs)(n.p,{children:["Create a type-safe decorator from your policy manager using the ",(0,i.jsx)(n.code,{children:"createDecorator"})," method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const policy = policyManager.createDecorator();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"class-level-policies",children:"Class-Level Policies"}),"\n",(0,i.jsx)(n.p,{children:"Apply policies to an entire controller class:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@policy('users', 'adminRoute')\nclass AdminController {\n  // All routes in this controller require admin access\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"method-level-policies",children:"Method-Level Policies"}),"\n",(0,i.jsx)(n.p,{children:"You can also apply policies to individual methods:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class UserController {\n  @policy('users', 'canView')\n  async getUser(req: Request, res: Response) {\n    // Only users with 'canView' permission can access this route\n  }\n\n  @policy('users', 'canEdit')\n  async updateUser(req: Request, res: Response) {\n    // Only users with 'canEdit' permission can access this route\n  }\n\n  @policy('users', 'canDelete')\n  async deleteUser(req: Request, res: Response) {\n    // Only users with 'canDelete' permission can access this route\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"combining-class-and-method-policies",children:"Combining Class and Method Policies"}),"\n",(0,i.jsx)(n.p,{children:"Policies can be stacked - class-level policies apply to all methods, and method-level policies add additional checks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"@policy('users', 'adminRoute')\nclass AdminController {\n  @policy('documents', 'canEdit')\n  async editDocument(req: Request, res: Response) {\n    // Requires both 'users.adminRoute' AND 'documents.canEdit' policies\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"controller-example",children:"Controller Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const adminRoute = async (req: Request, res: Response) => {\n  const user = req.user;\n  const hasAccess = await policyManager.canAccess('users', 'adminRoute', user);\n  if (!hasAccess) {\n    return res.forbidden({ message: 'You do not have access to this route' });\n  }\n\n  return res.ok({ message: 'You have access to this route' });\n};\n"})})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var r=s(6540);const i={},c=r.createContext(i);function o(e){const n=r.useContext(c);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(c.Provider,{value:n},e.children)}}}]);