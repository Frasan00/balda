"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6271],{7605:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"websockets/overview","title":"WebSockets","description":"WebSockets provide a full-duplex communication channel over a single TCP connection, enabling real-time bidirectional communication between clients and servers. Balda supports WebSockets across all three runtimes (Node.js, Bun, and Deno) with runtime-specific configurations.","source":"@site/docs/websockets/overview.md","sourceDirName":"websockets","slug":"/websockets/overview","permalink":"/balda/docs/websockets/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/balda/tree/main/docs/docs/websockets/overview.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Error Handling","permalink":"/balda/docs/core-concepts/error-handling"},"next":{"title":"GraphQL","permalink":"/balda/docs/graphql/overview"}}');var i=s(4848),o=s(8453);const t={},l="WebSockets",c={},d=[{value:"Overview",id:"overview",level:2},{value:"When WebSocket Upgrade Happens",id:"when-websocket-upgrade-happens",level:2},{value:"Runtime-Specific Implementations",id:"runtime-specific-implementations",level:2},{value:"Node.js",id:"nodejs",level:3},{value:"Installation",id:"installation",level:4},{value:"Usage",id:"usage",level:4},{value:"Key Points",id:"key-points",level:4},{value:"Bun",id:"bun",level:3},{value:"Usage",id:"usage-1",level:4},{value:"WebSocket Handler Methods",id:"websocket-handler-methods",level:4},{value:"How WebSocket Upgrade Works",id:"how-websocket-upgrade-works",level:4},{value:"Deno",id:"deno",level:3},{value:"Usage",id:"usage-2",level:4},{value:"WebSocket Handler Methods",id:"websocket-handler-methods-1",level:4},{value:"How WebSocket Upgrade Works",id:"how-websocket-upgrade-works-1",level:4},{value:"Comparison Table",id:"comparison-table",level:2},{value:"Security Considerations",id:"security-considerations",level:2},{value:"1. Validate Origin",id:"1-validate-origin",level:3},{value:"2. Authenticate Connections",id:"2-authenticate-connections",level:3},{value:"3. Input Sanitization",id:"3-input-sanitization",level:3},{value:"Summary",id:"summary",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"websockets",children:"WebSockets"})}),"\n",(0,i.jsx)(n.p,{children:"WebSockets provide a full-duplex communication channel over a single TCP connection, enabling real-time bidirectional communication between clients and servers. Balda supports WebSockets across all three runtimes (Node.js, Bun, and Deno) with runtime-specific configurations."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"WebSocket support in Balda is:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime-specific"}),": Each runtime (Node.js, Bun, Deno) has its own implementation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Opt-in"}),": WebSocket upgrade only happens when explicitly configured"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flexible"}),": Configure handlers for connection lifecycle events (open, message, close)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-websocket-upgrade-happens",children:"When WebSocket Upgrade Happens"}),"\n",(0,i.jsxs)(n.p,{children:["WebSocket upgrade is triggered when ",(0,i.jsx)(n.strong,{children:"both"})," conditions are met:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The client sends a request with the ",(0,i.jsx)(n.code,{children:"Upgrade: websocket"})," header"]}),"\n",(0,i.jsxs)(n.li,{children:["WebSocket configuration is provided in the server's ",(0,i.jsx)(n.code,{children:"tapOptions"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If WebSocket configuration is ",(0,i.jsx)(n.strong,{children:"not provided"}),", the server will handle all requests normally without attempting any WebSocket upgrades."]}),"\n",(0,i.jsx)(n.h2,{id:"runtime-specific-implementations",children:"Runtime-Specific Implementations"}),"\n",(0,i.jsx)(n.h3,{id:"nodejs",children:"Node.js"}),"\n",(0,i.jsxs)(n.p,{children:["For Node.js, Balda doesn't provide built-in WebSocket handling. Instead, you can use the popular ",(0,i.jsx)(n.code,{children:"ws"})," library to create a WebSocket server that attaches to the underlying HTTP server."]}),"\n",(0,i.jsx)(n.h4,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"npm install ws\n"})}),"\n",(0,i.jsx)(n.h4,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { Server } from "balda";\nimport { WebSocketServer } from "ws";\n\nconst server = new Server({\n  port: 8080,\n  host: "0.0.0.0",\n  nodeHttpClient: "http",\n});\n\n// Get the underlying Node.js server\nconst nodeServer = server.getNodeServer();\n\n// Create WebSocket server\nconst wss = new WebSocketServer({\n  server: nodeServer,\n  path: "/ws",\n});\n\nwss.on("connection", (ws) => {\n  console.log("New WebSocket connection");\n\n  ws.send("Hello from server");\n\n  ws.on("message", (data) => {\n    console.log("Received:", data.toString());\n    ws.send(`Echo: ${data}`);\n  });\n\n  ws.on("close", () => {\n    console.log("Connection closed");\n  });\n});\n\nserver.listen(({ url }) => {\n  console.log(`Server listening on ${url}`);\n});\n'})}),"\n",(0,i.jsx)(n.h4,{id:"key-points",children:"Key Points"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Uses the standard ",(0,i.jsx)(n.code,{children:"ws"})," library"]}),"\n",(0,i.jsxs)(n.li,{children:["Requires getting the underlying Node server with ",(0,i.jsx)(n.code,{children:"server.getNodeServer()"})]}),"\n",(0,i.jsx)(n.li,{children:"Full control over WebSocket path and configuration"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"bun",children:"Bun"}),"\n",(0,i.jsxs)(n.p,{children:["Bun has native WebSocket support built into ",(0,i.jsx)(n.code,{children:"Bun.serve()"}),". Balda exposes this through the ",(0,i.jsx)(n.code,{children:"tapOptions.bun.websocket"})," configuration."]}),"\n",(0,i.jsx)(n.h4,{id:"usage-1",children:"Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { Server } from "balda";\n\nconst server = new Server({\n  port: 8080,\n  host: "0.0.0.0",\n  tapOptions: {\n    bun: {\n      websocket: {\n        open(ws) {\n          console.log("WebSocket opened");\n          ws.send("Welcome to Bun WebSocket!");\n        },\n        message(ws, message) {\n          console.log("Received:", message);\n          ws.send(`Echo: ${message}`);\n        },\n        close(ws, code, reason) {\n          console.log(`Connection closed: ${code} - ${reason}`);\n        },\n        drain(ws) {\n          console.log("Socket is ready to receive more data");\n        },\n      },\n    },\n  },\n});\n\nserver.listen(({ url }) => {\n  console.log(`Server listening on ${url}`);\n});\n'})}),"\n",(0,i.jsx)(n.h4,{id:"websocket-handler-methods",children:"WebSocket Handler Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"open(ws: ServerWebSocket)"}),": Called when a WebSocket connection is established"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"message(ws: ServerWebSocket, message: string | Buffer)"}),": Called when a message is received"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"close(ws: ServerWebSocket, code: number, reason: string)"}),": Called when connection closes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"drain(ws: ServerWebSocket)"}),": Called when the socket is ready to receive more data (backpressure)"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"how-websocket-upgrade-works",children:"How WebSocket Upgrade Works"}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"tapOptions.bun.websocket"})," is configured:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The framework passes the websocket configuration to ",(0,i.jsx)(n.code,{children:"Bun.serve()"})]}),"\n",(0,i.jsxs)(n.li,{children:["On incoming requests with ",(0,i.jsx)(n.code,{children:"Upgrade: websocket"})," header, the server attempts upgrade"]}),"\n",(0,i.jsx)(n.li,{children:"If upgrade succeeds, your handlers are called at appropriate lifecycle events"}),"\n",(0,i.jsx)(n.li,{children:"If no websocket config is provided, requests are handled normally (no upgrade attempted)"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"deno",children:"Deno"}),"\n",(0,i.jsxs)(n.p,{children:["Deno also has native WebSocket support. Balda exposes this through the ",(0,i.jsx)(n.code,{children:"tapOptions.deno.websocket"})," configuration."]}),"\n",(0,i.jsx)(n.h4,{id:"usage-2",children:"Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'import { Server } from "balda";\n\nconst server = new Server({\n  port: 8080,\n  host: "0.0.0.0",\n  tapOptions: {\n    deno: {\n      websocket: {\n        open(ws) {\n          console.log("WebSocket opened");\n          ws.send("Welcome to Deno WebSocket!");\n        },\n        message(ws, message) {\n          console.log("Received:", message);\n          ws.send(`Echo: ${message}`);\n        },\n        close(ws) {\n          console.log("Connection closed");\n        },\n      },\n    },\n  },\n});\n\nserver.listen(({ url }) => {\n  console.log(`Server listening on ${url}`);\n});\n'})}),"\n",(0,i.jsx)(n.h4,{id:"websocket-handler-methods-1",children:"WebSocket Handler Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"open(ws: WebSocket)"}),": Called when a WebSocket connection is established"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"message(ws: WebSocket, message: string)"}),": Called when a message is received"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"close(ws: WebSocket)"}),": Called when connection closes"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"how-websocket-upgrade-works-1",children:"How WebSocket Upgrade Works"}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"tapOptions.deno.websocket"})," is configured:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["On incoming requests with ",(0,i.jsx)(n.code,{children:"Upgrade: websocket"})," header, ",(0,i.jsx)(n.code,{children:"Deno.upgradeWebSocket()"})," is called"]}),"\n",(0,i.jsx)(n.li,{children:"Event handlers (onopen, onmessage, onclose) are attached to the WebSocket"}),"\n",(0,i.jsx)(n.li,{children:"The upgrade response is returned to the client"}),"\n",(0,i.jsx)(n.li,{children:"Your handlers are called at appropriate lifecycle events"}),"\n",(0,i.jsx)(n.li,{children:"If no websocket config is provided, requests are handled normally (no upgrade attempted)"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"comparison-table",children:"Comparison Table"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Feature"}),(0,i.jsx)(n.th,{children:"Node.js"}),(0,i.jsx)(n.th,{children:"Bun"}),(0,i.jsx)(n.th,{children:"Deno"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Library"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"ws"})," (external)"]}),(0,i.jsx)(n.td,{children:"Native"}),(0,i.jsx)(n.td,{children:"Native"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Configuration"})}),(0,i.jsx)(n.td,{children:"Direct API"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"tapOptions.bun.websocket"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"tapOptions.deno.websocket"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Auto Upgrade"})}),(0,i.jsx)(n.td,{children:"Manual setup"}),(0,i.jsx)(n.td,{children:"Automatic when configured"}),(0,i.jsx)(n.td,{children:"Automatic when configured"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Path Control"})}),(0,i.jsx)(n.td,{children:"Full control"}),(0,i.jsx)(n.td,{children:"All upgrade requests"}),(0,i.jsx)(n.td,{children:"All upgrade requests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Type"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ws.WebSocket"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ServerWebSocket"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"WebSocket"})})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"1-validate-origin",children:"1. Validate Origin"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Node.js\nwss.on("connection", (ws, req) => {\n  const origin = req.headers.origin;\n  if (!isAllowedOrigin(origin)) {\n    ws.close(1008, "Origin not allowed");\n    return;\n  }\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-authenticate-connections",children:"2. Authenticate Connections"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Use query parameters or headers for authentication\nwss.on("connection", (ws, req) => {\n  const url = new URL(req.url!, `http://${req.headers.host}`);\n  const token = url.searchParams.get("token");\n\n  if (!isValidToken(token)) {\n    ws.close(1008, "Unauthorized");\n    return;\n  }\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-input-sanitization",children:"3. Input Sanitization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'message(ws, message) {\n  // Sanitize and validate all input\n  const sanitized = sanitizeInput(message);\n  const validated = validateMessage(sanitized);\n\n  if (!validated) {\n    ws.send(JSON.stringify({ error: "Invalid input" }));\n    return;\n  }\n\n  processMessage(validated);\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"WebSocket support in Balda is:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime-aware"}),": Different implementations for Node.js, Bun, and Deno"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Opt-in"}),": Only enabled when explicitly configured"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safe by default"}),": No upgrade attempts without configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flexible"}),": Full control over connection lifecycle"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Choose the approach that best fits your runtime:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Node.js"}),": Use ",(0,i.jsx)(n.code,{children:"ws"})," library for maximum control and ecosystem compatibility"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bun"}),": Use native websocket with excellent performance and backpressure handling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deno"}),": Use native websocket with Web standard APIs"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var r=s(6540);const i={},o=r.createContext(i);function t(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);