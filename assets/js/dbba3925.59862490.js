"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1325],{6772:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"core-concepts/request-response","title":"Request & Response","description":"Balda provides a clean and intuitive API for handling HTTP requests and responses. The framework provides custom Request and Response classes with built-in compatibility layers for seamless interoperability with Web API Request/Response objects through fromRequest(), toWebApi(), and toWebResponse() methods.","source":"@site/docs/core-concepts/request-response.md","sourceDirName":"core-concepts","slug":"/core-concepts/request-response","permalink":"/balda/docs/core-concepts/request-response","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/balda/tree/main/docs/docs/core-concepts/request-response.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"docs","previous":{"title":"Middleware","permalink":"/balda/docs/core-concepts/middleware"},"next":{"title":"Streaming Responses","permalink":"/balda/docs/core-concepts/streaming"}}');var t=s(4848),i=s(8453);const a={sidebar_position:5},o="Request & Response",d={},l=[{value:"Request Object",id:"request-object",level:2},{value:"Basic Properties",id:"basic-properties",level:3},{value:"Accessing Request Data",id:"accessing-request-data",level:3},{value:"Type-Safe Request-Response",id:"type-safe-request-response",level:3},{value:"File Uploads",id:"file-uploads",level:3},{value:"Response Object",id:"response-object",level:2},{value:"Status Methods",id:"status-methods",level:3},{value:"Content Methods",id:"content-methods",level:3},{value:"Header Management",id:"header-management",level:3},{value:"Cookie Management",id:"cookie-management",level:3},{value:"Request Validation",id:"request-validation",level:2},{value:"Two Ways to Validate",id:"two-ways-to-validate",level:3},{value:"1. Decorator-Based Validation (Controllers)",id:"1-decorator-based-validation-controllers",level:4},{value:"2. Inline Validation (Direct Routes)",id:"2-inline-validation-direct-routes",level:4},{value:"Built-in Validation Features",id:"built-in-validation-features",level:3},{value:"Query Parameter Validation",id:"query-parameter-validation",level:4},{value:"Combined Body + Query Validation",id:"combined-body--query-validation",level:4},{value:"Using JSON Schemas Directly",id:"using-json-schemas-directly",level:3},{value:"Using TypeBox Schemas",id:"using-typebox-schemas",level:3},{value:"Custom AJV Instance",id:"custom-ajv-instance",level:3},{value:"Response Serialization",id:"response-serialization",level:2},{value:"Inline Route Schemas",id:"inline-route-schemas",level:3},{value:"Decorator-based Serialization",id:"decorator-based-serialization",level:3},{value:"Multiple Response Schemas",id:"multiple-response-schemas",level:3},{value:"Fast JSON Serialization",id:"fast-json-serialization",level:3},{value:"When fast-json-stringify is Used",id:"when-fast-json-stringify-is-used",level:4},{value:"How It Works",id:"how-it-works",level:4},{value:"Validation Mode",id:"validation-mode",level:4},{value:"Schema Caching",id:"schema-caching",level:4},{value:"Error Handling",id:"error-handling",level:2},{value:"Custom Error Responses",id:"custom-error-responses",level:3},{value:"Global Error Handler",id:"global-error-handler",level:3},{value:"Request Lifecycle",id:"request-lifecycle",level:2},{value:"Middleware Chain",id:"middleware-chain",level:3},{value:"TypeScript Support",id:"typescript-support",level:2},{value:"Request Extensions",id:"request-extensions",level:3},{value:"Response Types",id:"response-types",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Consistent Response Format",id:"1-consistent-response-format",level:3},{value:"2. Proper Status Codes",id:"2-proper-status-codes",level:3},{value:"3. Input Validation",id:"3-input-validation",level:3},{value:"4. Error Handling",id:"4-error-handling",level:3},{value:"5. Security Headers",id:"5-security-headers",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"request--response",children:"Request & Response"})}),"\n",(0,t.jsxs)(n.p,{children:["Balda provides a clean and intuitive API for handling HTTP requests and responses. The framework provides custom Request and Response classes with built-in compatibility layers for seamless interoperability with Web API Request/Response objects through ",(0,t.jsx)(n.code,{children:"fromRequest()"}),", ",(0,t.jsx)(n.code,{children:"toWebApi()"}),", and ",(0,t.jsx)(n.code,{children:"toWebResponse()"})," methods."]}),"\n",(0,t.jsx)(n.h2,{id:"request-object",children:"Request Object"}),"\n",(0,t.jsx)(n.p,{children:"The request object contains information about the incoming HTTP request."}),"\n",(0,t.jsx)(n.h3,{id:"basic-properties",children:"Basic Properties"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface Request {\n  method: string; // HTTP method (GET, POST, etc.)\n  url: string; // Request URL\n  path: string; // Request path\n  headers: Record<string, string>; // Request headers\n  query: Record<string, string>; // Query parameters\n  params: Record<string, string>; // Route parameters\n  body: any; // Parsed request body from body parser middleware\n  ip: string; // Client IP address\n  cookies: Record<string, string>; // Request cookies\n}\n"})}),"\n",(0,t.jsxs)(n.admonition,{title:"Web API Compatibility",type:"info",children:[(0,t.jsx)(n.p,{children:"Balda's Request class provides compatibility with Web API Request objects through:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"Request.fromRequest(webRequest)"})}),": Converts a Web API Request to a Balda Request"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"req.toWebApi()"})}),": Converts a Balda Request back to a Web API Request"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"req.body"})}),": Contains the parsed request body set by body parser middleware (JSON, URL-encoded, or file uploads). ",(0,t.jsx)(n.strong,{children:"Use this in your route handlers"}),"."]}),"\n"]})]}),"\n",(0,t.jsx)(n.h3,{id:"accessing-request-data",children:"Accessing Request Data"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@get('/users/:id')\nasync getUser(req: Request, res: Response) {\n  // Route parameters\n  const userId = req.params.id;\n\n  // Query parameters\n  const { page = 1, limit = 10 } = req.query;\n\n  // Headers\n  const userAgent = req.headers['user-agent'];\n  const authToken = req.headers.authorization;\n\n  // Parsed request body (for POST/PUT/PATCH, automatically set by body parser middleware)\n  const userData = req.body;  // Available when using body parser middleware (json, urlencoded, or file)\n\n  // Client IP\n  const clientIP = req.ip;\n\n  // standard response handling\n  res.json({ userId, page, limit, userAgent, clientIP });\n\n  // shortcut for simple objects\n  return { userId, page, limit, userAgent, clientIP }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"type-safe-request-response",children:"Type-Safe Request-Response"}),"\n",(0,t.jsx)(n.p,{children:"Balda provides automatic type inference for both request parameters and response bodies:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { z } from "zod";\n\nconst UserSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  email: z.string(),\n});\n\nconst ErrorSchema = z.object({\n  error: z.string(),\n});\n\n// Path parameters are inferred from the route path\n// Response bodies are inferred from responses schemas\nrouter.get(\n  "/users/:id",\n  {\n    responses: {\n      200: UserSchema,\n      404: ErrorSchema,\n    },\n  },\n  (req, res) => {\n    const { id } = req.params; // \u2705 Typed as { id: string }\n\n    res.ok({ id, name: "John", email: "john@example.com" }); // \u2705 Typed as { id: string; name: string; email: string }\n    res.notFound({ error: "User not found" }); // \u2705 Typed as { error: string }\n\n    // res.ok({ wrong: 123 });  // \u274c Type error\n  },\n);\n\n// With validation \u2014 inline validation assigns typed data to `req.body`\nconst CreateUserSchema = z.object({ name: z.string(), email: z.string() });\n\nrouter.post("/users", { body: CreateUserSchema }, (req, res) => {\n  // req.body is typed as z.infer<typeof CreateUserSchema>\n  res.created({ id: "123", ...req.body });\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:["For controller-based routes, use the ",(0,t.jsx)(n.code,{children:"@validate"})," decorator and manually type the ",(0,t.jsx)(n.code,{children:"Response"})," generic:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@post('/:userId/posts')\n@validate.body(CreatePostSchema)\n@validate.query(PostQuerySchema)\nasync createPost(\n  req: Request<{ userId: string }>,\n  res: Response<{ 201: PostResponse }>,\n  body: z.infer<typeof CreatePostSchema>,\n  query: z.infer<typeof PostQuerySchema>\n) {\n  const { userId } = req.params;\n  const { title, content } = body;\n  const { draft = false } = query;\n  res.created({ id: 'post-123', userId, title, content, draft }); // \u2705 Typed as PostResponse\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": ",(0,t.jsx)(n.code,{children:"req.body"})," and ",(0,t.jsx)(n.code,{children:"req.query"})," are untyped until validated. Inline route validation (via route options ",(0,t.jsx)(n.code,{children:"body"}),"/",(0,t.jsx)(n.code,{children:"query"}),"/",(0,t.jsx)(n.code,{children:"all"}),") writes typed data to ",(0,t.jsx)(n.code,{children:"req.body"}),"/",(0,t.jsx)(n.code,{children:"req.query"}),", while the ",(0,t.jsx)(n.code,{children:"@validate"})," decorators used on controller methods still inject validated arguments into the method signature."]}),"\n",(0,t.jsx)(n.h3,{id:"file-uploads",children:"File Uploads"}),"\n",(0,t.jsxs)(n.p,{children:["Handle file uploads with ",(0,t.jsx)(n.code,{children:"bodyType: 'form-data'"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { controller, post } from "balda";\nimport { z } from "zod";\n\n@controller("/upload")\nexport class UploadController {\n  @post("/", { bodyType: "form-data" })\n  async upload(req, res) {\n    const file = req.file("fieldName"); // Get file by field name\n\n    if (!file) {\n      return res.badRequest({ error: "No file uploaded" });\n    }\n\n    res.ok({\n      originalName: file.originalName, // Original filename\n      formName: file.formName, // Form field name\n      size: file.size, // File size in bytes\n      mimeType: file.mimeType, // MIME type\n      content: file.content, // File content as Uint8Array\n    });\n\n    // Other form fields available in req.body\n    const { description } = req.body;\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Configure file upload limits:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const server = new Server({\n  plugins: {\n    bodyParser: {\n      fileParser: {\n        maxFiles: 10,\n        maxFileSize: "10mb",\n      },\n    },\n  },\n});\n'})}),"\n",(0,t.jsx)(n.h2,{id:"response-object",children:"Response Object"}),"\n",(0,t.jsx)(n.p,{children:"The response object provides methods for sending HTTP responses."}),"\n",(0,t.jsx)(n.h3,{id:"status-methods",children:"Status Methods"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Request, Response } from 'balda';\n\n@get('/users')\nasync getUsers(req: Request, res: Response) {\n  // Success responses\n  res.ok({ users: [] });                    // 200 OK\n  res.created({ id: 1 });                   // 201 Created\n  res.accepted({ jobId: 123 });             // 202 Accepted\n  res.noContent();                          // 204 No Content\n\n  // Client error responses\n  res.badRequest({ error: 'Invalid data' }); // 400 Bad Request\n  res.unauthorized({ error: 'Auth required' }); // 401 Unauthorized\n  res.forbidden({ error: 'Access denied' });    // 403 Forbidden\n  res.notFound({ error: 'User not found' });    // 404 Not Found\n  res.conflict({ error: 'User exists' });       // 409 Conflict\n  res.tooManyRequests({ error: 'Rate limited' }); // 429 Too Many Requests\n\n  // Server error responses\n  res.internalServerError({ error: 'Server error' }); // 500 Internal Server Error\n  res.notImplemented({ error: 'Not implemented' });   // 501 Not Implemented\n  res.badGateway({ error: 'Bad gateway' });           // 502 Bad Gateway\n  res.serviceUnavailable({ error: 'Unavailable' });   // 503 Service Unavailable\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"content-methods",children:"Content Methods"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Request, Response } from 'balda';\n\n@get('/api/data')\nasync getData(req: Request, res: Response) {\n  // Manually set headers\n  res.setHeader('X-Custom-Header', 'value');\n\n  // JSON response\n  res.json({ message: 'Hello World' });\n\n  // Text response\n  res.text('Hello World');\n\n  // HTML response\n  res.html('<h1>Hello World</h1>');\n\n  // Redirect\n  res.redirect('/new-location');\n\n  // Download file\n  res.download('/path/to/file.pdf', 'filename.pdf');\n\n  // Send tries to understand the best content type to send based on the body (better to use specific methods)\n  res.send({ message: 'Hello World' });\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"header-management",children:"Header Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Request, Response } from 'balda';\n\n@get('/api/data')\nasync getData(req: Request, res: Response) {\n  // Set headers\n  res.setHeader('Content-Type', 'application/json');\n  res.setHeader('Cache-Control', 'no-cache');\n\n  // Set multiple headers\n  res.setHeaders({\n    'Content-Type': 'application/json',\n    'X-Custom-Header': 'value'\n  });\n\n  // Get headers\n  const contentType = res.getHeader('Content-Type');\n\n  res.json({ data: 'value' });\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cookie-management",children:"Cookie Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Request, Response } from 'balda';\n\n@post('/login')\nasync login(req: Request, res: Response) {\n  // Set cookies\n  res.setCookie('sessionId', 'abc123', {\n    httpOnly: true,\n    secure: true,\n    maxAge: 24 * 60 * 60 * 1000 // 24 hours\n  });\n\n  // Clear cookies\n  res.clearCookie('oldSession');\n\n  res.json({ message: 'Logged in' });\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"request-validation",children:"Request Validation"}),"\n",(0,t.jsx)(n.p,{children:"Balda supports request validation using Zod, TypeBox, or plain JSON schemas. Validation is powered by AJV for performance, with schemas compiled once and cached for the server's lifetime."}),"\n",(0,t.jsx)(n.h3,{id:"two-ways-to-validate",children:"Two Ways to Validate"}),"\n",(0,t.jsx)(n.h4,{id:"1-decorator-based-validation-controllers",children:"1. Decorator-Based Validation (Controllers)"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"@validate"})," decorators in controller classes. Validated data is automatically injected as additional handler parameters."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { controller, post, validate } from "balda";\nimport { z } from "zod";\n\nconst CreateUserSchema = z.object({\n  name: z.string().min(1),\n  email: z.string().email(),\n  age: z.number().min(18),\n});\n\n@controller("/users")\nexport class UsersController {\n  @post("/")\n  @validate.body(CreateUserSchema)\n  async createUser(\n    req: Request,\n    res: Response,\n    body: z.infer<typeof CreateUserSchema>,\n  ) {\n    // body is validated and typed\n    const { name, email, age } = body;\n    res.created({ name, email, age });\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"2-inline-validation-direct-routes",children:"2. Inline Validation (Direct Routes)"}),"\n",(0,t.jsxs)(n.p,{children:["For inline route definitions, use the ",(0,t.jsx)(n.code,{children:"body"}),", ",(0,t.jsx)(n.code,{children:"query"}),", or ",(0,t.jsx)(n.code,{children:"all"})," options. Validated data is written back to the request object (",(0,t.jsx)(n.code,{children:"req.body"})," and ",(0,t.jsx)(n.code,{children:"req.query"}),"), so your handler can remain ",(0,t.jsx)(n.code,{children:"(req, res)"})," and access typed values directly."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Server } from "balda";\nimport { z } from "zod";\n\nconst server = new Server();\n\nconst CreateUserSchema = z.object({\n  name: z.string().min(1),\n  email: z.string().email(),\n  age: z.number().min(18),\n});\n\n// Validate request body \u2014 validated data is written to `req.body`\nserver.router.post(\n  "/users",\n  {\n    body: CreateUserSchema,\n    responses: {\n      201: UserResponseSchema,\n    },\n  },\n  (req, res) => {\n    // req.body is typed as z.infer<typeof CreateUserSchema>\n    const { name, email, age } = req.body;\n    res.created({ name, email, age });\n  },\n);\n\n// Validate query parameters \u2014 validated data is written to `req.query`\nconst PaginationSchema = z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(100).default(10),\n});\n\nrouter.get(\n  "/users",\n  {\n    query: PaginationSchema,\n  },\n  (req, res) => {\n    const { page, limit } = req.query;\n    res.json({ users: [], page, limit });\n  },\n);\n\n// Validate both body and query \u2014 both `req.body` and `req.query` are typed\nrouter.post(\n  "/search",\n  {\n    body: SearchBodySchema,\n    query: SearchQuerySchema,\n  },\n  (req, res) => {\n    res.json({ results: [], body: req.body, query: req.query });\n  },\n);\n\n// Validate all (body + query merged) \u2014 merged validated object is written to `req.body`\nrouter.post(\n  "/filter",\n  {\n    all: FilterSchema, // Merges body and query into single validated object\n  },\n  (req, res) => {\n    // req.body contains merged body + query\n    res.json({ filtered: req.body });\n  },\n);\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameter Order:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Inline validation: handler signature is ",(0,t.jsx)(n.code,{children:"(req, res)"}),"; validated data is available on ",(0,t.jsx)(n.code,{children:"req.body"})," and/or ",(0,t.jsx)(n.code,{children:"req.query"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Decorator-based validation (",(0,t.jsx)(n.code,{children:"@validate"}),"): validated data is injected as additional method parameters (legacy behavior)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"By default, validation throws errors on invalid data and returns 400 responses."})," Validation happens automatically before your handler executes."]}),"\n",(0,t.jsx)(n.h3,{id:"built-in-validation-features",children:"Built-in Validation Features"}),"\n",(0,t.jsxs)(n.p,{children:["Zod is a peer dependency loaded only when Zod schemas are used. Schemas are compiled once and cached during the server lifecycle\u2014no compilation overhead on subsequent requests. Zod4 is required with the ",(0,t.jsx)(n.code,{children:"toJSONSchema()"})," method."]}),"\n",(0,t.jsx)(n.h4,{id:"query-parameter-validation",children:"Query Parameter Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { controller, get, validate } from "balda";\nimport { z } from "zod";\n\nconst QuerySchema = z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(100).default(10),\n});\n\n@controller("/users")\nexport class UsersController {\n  @get("/")\n  @validate.query(QuerySchema)\n  async getUsers(\n    req: Request,\n    res: Response,\n    query: z.infer<typeof QuerySchema>,\n  ) {\n    const { page, limit } = query;\n    res.json({ users: [], page, limit });\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Or with inline routes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'router.get(\n  "/users",\n  {\n    query: QuerySchema,\n  },\n  (req, res, validatedQuery) => {\n    const { page, limit } = validatedQuery;\n    res.json({ users: [], page, limit });\n  },\n);\n'})}),"\n",(0,t.jsx)(n.h4,{id:"combined-body--query-validation",children:"Combined Body + Query Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Decorator approach\n@post('/search')\n@validate.body(SearchBodySchema)\n@validate.query(SearchQuerySchema)\nasync search(req: Request, res: Response, body: SearchBody, query: SearchQuery) {\n  // Both injected in order\n}\n\n// Inline approach\nrouter.post('/search', {\n  body: SearchBodySchema,\n  query: SearchQuerySchema\n}, (req, res, validatedBody, validatedQuery) => {\n  // Both injected in order\n  res.json({ results: [] });\n});\n\n// Or validate all (body + query merged)\nrouter.post('/filter', {\n  all: FilterSchema  // Merges body and query\n}, (req, res, validatedAll) => {\n  res.json({ filtered: validatedAll });\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"using-json-schemas-directly",children:"Using JSON Schemas Directly"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@post('/users')\n@validate.body({\n  type: 'object',\n  properties: {\n    name: { type: 'string', minLength: 1 },\n    email: { type: 'string', format: 'email' },\n    age: { type: 'number', minimum: 18 }\n  },\n  required: ['name', 'email']\n})\nasync createUser(req: Request, res: Response, body: any) {\n  // body parameter contains the validated data\n  // req.body also contains the validated data\n  res.created(body);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"using-typebox-schemas",children:"Using TypeBox Schemas"}),"\n",(0,t.jsx)(n.p,{children:"TypeBox provides type-safe JSON Schema with full TypeScript type inference. It's a lightweight alternative to Zod with excellent performance."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Request, Response, validate } from 'balda';\nimport { Type, Static } from '@sinclair/typebox';\n\nconst CreateUserSchema = Type.Object({\n  name: Type.String({ minLength: 1 }),\n  email: Type.String({ format: 'email' }),\n  age: Type.Number({ minimum: 18 })\n});\n\ntype CreateUser = Static<typeof CreateUserSchema>;\n\n@post('/users')\n@validate.body(CreateUserSchema)\nasync createUser(req: Request, res: Response, body: CreateUser) {\n  // body is validated and typed\n  const { name, email, age } = body;\n\n  res.created({ name, email, age });\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"TypeBox also supports advanced schema compositions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Type, Static } from "@sinclair/typebox";\n\n// Partial updates\nconst UpdateUserSchema = Type.Partial(\n  Type.Object({\n    name: Type.String(),\n    email: Type.String({ format: "email" }),\n    age: Type.Number({ minimum: 18 }),\n  }),\n);\n\n// Arrays\nconst UsersArraySchema = Type.Array(\n  Type.Object({\n    id: Type.Number(),\n    name: Type.String(),\n    email: Type.String(),\n  }),\n);\n\n// Union types\nconst ResponseSchema = Type.Union([\n  Type.Object({ success: Type.Literal(true), data: Type.Any() }),\n  Type.Object({ success: Type.Literal(false), error: Type.String() }),\n]);\n\n// Optional fields\nconst QuerySchema = Type.Object({\n  page: Type.Optional(Type.Number({ minimum: 1 })),\n  limit: Type.Optional(Type.Number({ minimum: 1, maximum: 100 })),\n});\n'})}),"\n",(0,t.jsx)(n.admonition,{title:"TypeBox Caching",type:"tip",children:(0,t.jsx)(n.p,{children:"TypeBox schemas are automatically cached just like Zod schemas. Each schema object is compiled to AJV once on first use, then reused for all subsequent validations. This makes TypeBox validation extremely fast\u2014especially since TypeBox schemas are already JSON Schema compliant and don't need conversion."})}),"\n",(0,t.jsxs)(n.admonition,{title:"Performance & Caching",type:"tip",children:[(0,t.jsx)(n.p,{children:"All schemas (Zod, TypeBox, and plain JSON schemas) are compiled once and cached for the lifetime of the server:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zod schemas"}),": Compiled from Zod \u2192 JSON Schema \u2192 AJV on first use, then cached"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TypeBox schemas"}),": Compiled directly to AJV on first use (already JSON Schema), then cached"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plain JSON schemas"}),": Compiled directly to AJV on first use, then cached"]}),"\n"]}),(0,t.jsxs)(n.p,{children:["Schema objects are tracked via WeakMap to ensure stable caching across your application. This means ",(0,t.jsx)(n.strong,{children:"zero compilation overhead"})," on subsequent requests\u2014validation is as fast as possible after the first use."]})]}),"\n",(0,t.jsxs)(n.admonition,{title:"Schema Libraries",type:"info",children:[(0,t.jsxs)(n.p,{children:["Both Zod and TypeBox are ",(0,t.jsx)(n.strong,{children:"peer dependencies"})," installed only if you use their schemas. They're lazy-loaded at runtime when needed, not bundled if unused."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Install Zod (requires zod4 with toJSONSchema() method)\nnpm install zod\n\n# Install TypeBox\nnpm install @sinclair/typebox\n\n# Or install both if you want to use them together\nnpm install zod @sinclair/typebox\n"})}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why use Zod?"})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Rich validation API with async refinements support (via ",(0,t.jsx)(n.code,{children:".parseAsync()"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"Excellent for complex validation logic"}),"\n",(0,t.jsx)(n.li,{children:"Great ecosystem and community"}),"\n",(0,t.jsx)(n.li,{children:"Schemas are converted to JSON Schema, then compiled and cached"}),"\n"]}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why use TypeBox?"})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Lightweight and fast (generates pure JSON Schema)"}),"\n",(0,t.jsxs)(n.li,{children:["Excellent type inference with ",(0,t.jsx)(n.code,{children:"Static<T>"})]}),"\n",(0,t.jsx)(n.li,{children:"Perfect for API-first development"}),"\n",(0,t.jsx)(n.li,{children:"Smaller bundle size"}),"\n",(0,t.jsx)(n.li,{children:"Already JSON Schema compliant\u2014compiles directly to AJV for maximum performance"}),"\n"]}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Caching Behavior:"}),"\nBoth libraries benefit from automatic schema caching. Define your schemas once, use them everywhere\u2014compilation happens only on first use, then cached for the server's lifetime."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// These schemas are compiled once and cached forever\nconst UserSchema = Type.Object({ name: Type.String() });\nconst ProductSchema = z.object({ name: z.string() });\n\n// First request: compiles and caches\n// All subsequent requests: uses cached compiled schema \u26a1\n"})}),(0,t.jsx)(n.p,{children:"Both libraries are first-class citizens in Balda and work seamlessly with validation decorators."})]}),"\n",(0,t.jsxs)(n.admonition,{title:"Synchronous Validation Only",type:"warning",children:[(0,t.jsxs)(n.p,{children:["Built-in validation supports ",(0,t.jsx)(n.strong,{children:"synchronous Zod schemas"})," only. Async refinements (",(0,t.jsx)(n.code,{children:".refine(async () => ...)"}),") are not supported."]}),(0,t.jsxs)(n.p,{children:["For async validation, use Zod's ",(0,t.jsx)(n.code,{children:".parseAsync()"})," directly:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@post('/users')\nasync createUser(req: Request, res: Response) {\n  const result = await CreateUserSchema.safeParseAsync(req.body);  // req.body automatically set by body parser middleware\n  if (!result.success) return res.badRequest(result.error);\n  res.created(result.data);\n}\n"})})]}),"\n",(0,t.jsx)(n.h3,{id:"custom-ajv-instance",children:"Custom AJV Instance"}),"\n",(0,t.jsx)(n.p,{children:"You can provide your own AJV instance with custom configuration for advanced use cases:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Ajv } from "ajv";\nimport { AjvStateManager } from "balda";\n\nconst customAjv = new Ajv({\n  validateSchema: false, // Required - must be false\n  strict: false, // Required - must be false\n  allErrors: true, // Optional - collect all errors\n  coerceTypes: true, // Optional - type coercion\n  // ... other custom options\n});\n\n// Add custom formats\ncustomAjv.addFormat("custom-format", /^[A-Z]{3}-\\d{4}$/);\n\n// Add custom keywords\ncustomAjv.addKeyword("isOdd", {\n  type: "number",\n  validate: (schema: any, data: number) => data % 2 === 1,\n});\n\n// Set as global instance (must be called before any validation)\nAjvStateManager.setGlobalInstance(customAjv);\n'})}),"\n",(0,t.jsxs)(n.admonition,{title:"Required Configuration",type:"danger",children:[(0,t.jsxs)(n.p,{children:["The following AJV options are ",(0,t.jsx)(n.strong,{children:"required"})," and must not be changed:"]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"validateSchema: false"})," - Required for proper Zod schema compilation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"strict: false"})," - Required for proper Zod schema compilation"]}),"\n"]}),(0,t.jsx)(n.p,{children:"Changing these values will cause validation errors and break Zod schema support."})]}),"\n",(0,t.jsxs)(n.admonition,{title:"When to Customize AJV",type:"tip",children:[(0,t.jsx)(n.p,{children:"Consider customizing the AJV instance when you need:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Custom validation formats (e.g., specific ID patterns)"}),"\n",(0,t.jsx)(n.li,{children:"Custom validation keywords"}),"\n",(0,t.jsxs)(n.li,{children:["Different error reporting (",(0,t.jsx)(n.code,{children:"allErrors: true"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Type coercion (",(0,t.jsx)(n.code,{children:"coerceTypes: true"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"Performance tuning for specific use cases"}),"\n"]})]}),"\n",(0,t.jsx)(n.h2,{id:"response-serialization",children:"Response Serialization"}),"\n",(0,t.jsxs)(n.p,{children:["Response schemas enable both ",(0,t.jsx)(n.strong,{children:"type safety"})," and ",(0,t.jsx)(n.strong,{children:"fast JSON serialization"}),". When you define schemas in ",(0,t.jsx)(n.code,{children:"responses"}),", Balda automatically uses ",(0,t.jsx)(n.a,{href:"https://github.com/fastify/fast-json-stringify",children:"fast-json-stringify"})," for high-performance serialization \u2014 no ",(0,t.jsx)(n.code,{children:"@serialize"})," decorator needed."]}),"\n",(0,t.jsx)(n.h3,{id:"inline-route-schemas",children:"Inline Route Schemas"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { z } from "zod";\n\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n  email: z.string(),\n});\n\n// Schemas provide both type safety AND fast serialization\nrouter.get(\n  "/users",\n  {\n    responses: {\n      200: z.array(UserSchema),\n    },\n  },\n  (req, res) => {\n    const users = await userService.findAll();\n    res.ok(users); // \u2705 Typed as { id: number; name: string; email: string }[]\n    // \u2705 Serialized with fast-json-stringify\n  },\n);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"decorator-based-serialization",children:"Decorator-based Serialization"}),"\n",(0,t.jsxs)(n.p,{children:["For controller-based routes, use the ",(0,t.jsx)(n.code,{children:"@serialize"})," decorator to enable fast serialization\nSince decorators cannot modify the function signature, the validated data is injected as an additional parameter."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Request, Response, serialize } from 'balda';\nimport z from 'zod';\nimport { Type } from '@sinclair/typebox';\n\n// Using Zod\nconst UserSchemaZod = z.object({\n  id: z.number(),\n  name: z.string(),\n  email: z.string()\n});\n\n@get('/users')\n@serialize(z.array(UserSchemaZod))\nasync getUsers(req: Request, res: Response) {\n  const users = await userService.findAll();\n  res.json(users);\n}\n\n// Using TypeBox\nconst UserSchemaTypeBox = Type.Object({\n  id: Type.Number(),\n  name: Type.String(),\n  email: Type.String()\n});\n\n@get('/users/:id')\n@serialize(UserSchemaTypeBox)\nasync getUser(req: Request, res: Response) {\n  const user = await userService.findById(req.params.id);\n  res.json(user);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"multiple-response-schemas",children:"Multiple Response Schemas"}),"\n",(0,t.jsx)(n.p,{children:"You can define multiple response schemas for different status codes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Request, Response, serialize } from 'balda';\nimport z from 'zod';\nimport { Type } from '@sinclair/typebox';\n\n// Using Zod\n@get('/users/:id')\n@serialize(UserSchemaZod)\n@serialize(z.object({ error: z.string() }), { status: 404 })\nasync getUser(req: Request, res: Response) {\n  const user = await userService.findById(req.params.id);\n\n  if (!user) {\n    return res.notFound({ error: 'User not found' });\n  }\n\n  res.json(user);\n}\n\n// Using TypeBox\n@get('/users/:id')\n@serialize(UserSchemaTypeBox)\n@serialize(Type.Object({ error: Type.Literal('User not found') }), { status: 404 })\nasync getUserTypeBox(req: Request, res: Response) {\n  const user = await userService.findById(req.params.id);\n\n  if (!user) {\n    return res.notFound({ error: 'User not found' });\n  }\n\n  res.json(user);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"fast-json-serialization",children:"Fast JSON Serialization"}),"\n",(0,t.jsxs)(n.p,{children:["Balda automatically uses ",(0,t.jsx)(n.a,{href:"https://github.com/fastify/fast-json-stringify",children:"fast-json-stringify"})," for high-performance JSON serialization when response schemas are available. This can be ",(0,t.jsx)(n.strong,{children:"2-5x faster"})," than ",(0,t.jsx)(n.code,{children:"JSON.stringify()"})," for complex objects."]}),"\n",(0,t.jsx)(n.h4,{id:"when-fast-json-stringify-is-used",children:"When fast-json-stringify is Used"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Scenario"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"fast-json-stringify"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Standard JSON.stringify"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"responses"})," schemas in route options"]}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"@serialize(schema)"})," decorator present"]}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"@serialize(schema, { throwErrorOnValidationFail: true })"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"No schemas defined"}),(0,t.jsx)(n.td,{style:{textAlign:"center"}}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Uses fast-json-stringify (schema in responses)\nrouter.get(\n  '/users',\n  { responses: { 200: UserSchema } },\n  (req, res) => {\n    res.ok(users);  // Serialized with fast-json-stringify + type-safe\n  },\n);\n\n// \u2705 Uses fast-json-stringify (schema provided via decorator)\n@get('/users')\n@serialize(UserSchema)\nasync getUsers(req: Request, res: Response) {\n  res.json(users);  // Serialized with fast-json-stringify\n}\n\n// \u274c Uses standard JSON.stringify (no schema)\nrouter.get('/health', (req, res) => {\n  res.json({ status: 'ok' });  // Serialized with JSON.stringify\n});\n"})}),"\n",(0,t.jsx)(n.h4,{id:"validation-mode",children:"Validation Mode"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"@serialize"})," decorator has a ",(0,t.jsx)(n.code,{children:"throwErrorOnValidationFail"})," option that controls validation behavior:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Validation disabled (default): No validation, uses fast-json-stringify for serialization\n@serialize(UserSchema)  // equivalent to @serialize(UserSchema, { throwErrorOnValidationFail: false })\n\n// Validation enabled: Validates response against schema, then uses fast-json-stringify\n@serialize(UserSchema, { throwErrorOnValidationFail: true })\n"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Mode"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Validation"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"fast-json-stringify"}),(0,t.jsx)(n.th,{children:"Use Case"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"throwErrorOnValidationFail: false"})," (default)"]}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u274c"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{children:"Production - maximum performance"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"throwErrorOnValidationFail: true"})}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{children:"Development - catch schema mismatches"})]})]})]}),"\n",(0,t.jsxs)(n.admonition,{title:"Performance Recommendation",type:"tip",children:[(0,t.jsxs)(n.p,{children:["Use the default mode (",(0,t.jsx)(n.code,{children:"throwErrorOnValidationFail: false"}),") in production for best performance. The schema is still used for fast serialization, but validation overhead is skipped."]}),(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"throwErrorOnValidationFail: true"})," during development to catch any mismatches between your response data and schema."]})]}),"\n",(0,t.jsx)(n.h4,{id:"schema-caching",children:"Schema Caching"}),"\n",(0,t.jsx)(n.p,{children:"All serializers are compiled once and cached for the lifetime of the server:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// First request: compiles fast-json-stringify serializer and caches it\n// All subsequent requests: reuses cached serializer \u26a1\n\n@get('/users')\n@serialize(UserSchema)\nasync getUsers(req: Request, res: Response) {\n  res.json(users);  // Uses cached serializer\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can monitor cache statistics for debugging:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { getSerializerCacheStats } from "balda";\n\nconst stats = getSerializerCacheStats();\nconsole.log(`Cached serializers: ${stats.size}`);\nconsole.log(`Schema refs created: ${stats.schemaRefsCreated}`);\n'})}),"\n",(0,t.jsxs)(n.admonition,{title:"Schema Support",type:"info",children:[(0,t.jsx)(n.p,{children:"fast-json-stringify works with all schema types:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zod schemas"}),": Converted to JSON Schema, then compiled"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TypeBox schemas"}),": Already JSON Schema compliant, compiled directly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plain JSON schemas"}),": Compiled directly"]}),"\n"]}),(0,t.jsx)(n.p,{children:"All schemas benefit from the same caching mechanism."})]}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.h3,{id:"custom-error-responses",children:"Custom Error Responses"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Request, Response } from 'balda';\n\n@get('/users/:id')\nasync getUser(req: Request, res: Response) {\n  try {\n    const user = await userService.findById(req.params.id);\n\n    if (!user) {\n      return res.notFound({\n        error: 'User not found',\n        code: 'USER_NOT_FOUND'\n      });\n    }\n\n    res.json(user);\n  } catch (error) {\n    console.error('Error fetching user:', error);\n    res.internalServerError({\n      error: 'Failed to fetch user',\n      code: 'FETCH_ERROR'\n    });\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"global-error-handler",children:"Global Error Handler"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Server } from "balda";\n\nserver.setErrorHandler((req, res, next, error) => {\n  console.error("Error:", error);\n\n  if (error.name === "ValidationError") {\n    return res.badRequest({\n      error: "Validation failed",\n      details: error.message,\n    });\n  }\n\n  if (error.name === "UnauthorizedError") {\n    return res.unauthorized({ error: "Authentication required" });\n  }\n\n  res.internalServerError({ error: "Internal server error" });\n});\n'})}),"\n",(0,t.jsx)(n.h2,{id:"request-lifecycle",children:"Request Lifecycle"}),"\n",(0,t.jsx)(n.h3,{id:"middleware-chain",children:"Middleware Chain"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import {\n  Server,\n  controller,\n  get,\n  post,\n  middleware,\n  validate,\n  cors,\n} from "balda";\nimport { Request, Response } from "balda";\nimport z from "zod";\nimport { authMiddleware } from "../auth/auth.md";\n\n// 1. Global middleware\nserver.use(cors);\n\n// 2. Controller middleware\n@controller("/users")\n@middleware(authMiddleware)\nexport class UsersController {\n  // 3. Route middleware\n  @get("/:id", { middleware: [rateLimit] })\n  // 4. Validation\n  @validate.params(z.object({ id: z.string() }))\n  // 5. Route handler\n  async getUser(req: Request, res: Response) {\n    // 6. Response serialization\n    res.json({ user: req.params.id });\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"typescript-support",children:"TypeScript Support"}),"\n",(0,t.jsx)(n.h3,{id:"request-extensions",children:"Request Extensions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { Request, Response } from 'balda';\n\ninterface AuthenticatedRequest extends Request {\n  user: {\n    id: number;\n    email: string;\n    role: string;\n  };\n}\n\n@get('/profile')\n@middleware(authMiddleware)\nasync getProfile(req: AuthenticatedRequest, res: Response) {\n  // req.user is now typed\n  res.json({\n    id: req.user.id,\n    email: req.user.email,\n    role: req.user.role\n  });\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"response-types",children:"Response Types"}),"\n",(0,t.jsxs)(n.p,{children:["When using inline route registration with ",(0,t.jsx)(n.code,{children:"responses"}),", each response shorthand method is automatically typed to its status code:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { z } from "zod";\nimport { Type } from "@sinclair/typebox";\n\n// Zod schemas \u2014 response types are inferred automatically\nrouter.get(\n  "/users/:id",\n  {\n    responses: {\n      200: z.object({ id: z.string(), name: z.string() }),\n      404: z.object({ error: z.string() }),\n    },\n  },\n  (req, res) => {\n    res.ok({ id: "1", name: "John" }); // \u2705 Typed to 200 schema\n    res.notFound({ error: "Not found" }); // \u2705 Typed to 404 schema\n    // res.ok({ wrong: true });           // \u274c Type error\n  },\n);\n\n// TypeBox schemas \u2014 same inference\nrouter.get(\n  "/posts",\n  {\n    responses: {\n      200: Type.Array(Type.Object({ title: Type.String() })),\n    },\n  },\n  (req, res) => {\n    res.ok([{ title: "Hello" }]); // \u2705 Typed as { title: string }[]\n  },\n);\n\n// Plain JSON Schema \u2014 resolves to `any` (no TS type representation)\nrouter.get(\n  "/health",\n  {\n    responses: {\n      200: { type: "object", properties: { status: { type: "string" } } },\n    },\n  },\n  (req, res) => {\n    res.ok({ status: "ok" }); // \u2705 No type constraints (any)\n  },\n);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["For controllers, you can manually type the ",(0,t.jsx)(n.code,{children:"Response"})," generic with a status-code-to-type map:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Request, Response } from \'balda\';\n\ninterface User { id: string; name: string; email: string }\ninterface ApiError { error: string }\n\n@get(\'/users/:id\')\nasync getUser(\n  req: Request<{ id: string }>,\n  res: Response<{ 200: User; 404: ApiError }>\n) {\n  res.ok({ id: "1", name: "John", email: "john@example.com" }); // \u2705 Typed as User\n  res.notFound({ error: "User not found" });                     // \u2705 Typed as ApiError\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{title:"Supported Schema Types",type:"info",children:(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Schema Type"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Type Inference"}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:"Serialization"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Zod"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705 Automatic"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705 fast-json-stringify"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"TypeBox"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705 Automatic"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705 fast-json-stringify"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"JSON Schema"}),(0,t.jsxs)(n.td,{style:{textAlign:"center"},children:["\u274c Resolves to ",(0,t.jsx)(n.code,{children:"any"})]}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705 fast-json-stringify"})]})]})]})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-consistent-response-format",children:"1. Consistent Response Format"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Good: Consistent structure\nres.json({\n  success: true,\n  data: { id: 1, name: "John" },\n  message: "User created successfully",\n});\n\n// Error response\nres.badRequest({\n  success: false,\n  error: "Validation failed",\n  details: ["Name is required"],\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-proper-status-codes",children:"2. Proper Status Codes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Use appropriate status codes\nres.created({ id: 1 }); // 201 for new resources\nres.noContent(); // 204 for successful deletion\nres.badRequest({ error: "" }); // 400 for client errors\nres.notFound({ error: "" }); // 404 for missing resources\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-input-validation",children:"3. Input Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@post('/users')\n@validate.body(CreateUserSchema)\nasync createUser(req: Request, res: Response, body: CreateUser) {\n  // body is validated and typed\n  const user = await userService.create(body);\n  res.created(user);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-error-handling",children:"4. Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@get('/users/:id')\nasync getUser(req: Request, res: Response) {\n  try {\n    const user = await userService.findById(req.params.id);\n\n    if (!user) {\n      return res.notFound({ error: 'User not found' });\n    }\n\n    res.json(user);\n  } catch (error) {\n    console.error('Database error:', error);\n    res.internalServerError({ error: 'Failed to fetch user' });\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-security-headers",children:"5. Security Headers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Set security headers\nres.setHeaders({\n  "X-Content-Type-Options": "nosniff",\n  "X-Frame-Options": "DENY",\n  "X-XSS-Protection": "1; mode=block",\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"The request and response objects in Balda provide a powerful and intuitive API for building robust web applications with proper error handling, validation, and type safety."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(6540);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);