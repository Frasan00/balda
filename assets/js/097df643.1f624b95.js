"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[108],{947:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"core-concepts/hashing","title":"Hashing","description":"Balda.js provides built-in secure password hashing functionality using industry-standard PBKDF2 with SHA-256. This feature is essential for securely storing user passwords and sensitive data.","source":"@site/docs/core-concepts/hashing.md","sourceDirName":"core-concepts","slug":"/core-concepts/hashing","permalink":"/balda-js/docs/core-concepts/hashing","draft":false,"unlisted":false,"editUrl":"https://github.com/Frasan00/balda-js/tree/main/docs/docs/core-concepts/hashing.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"docs","previous":{"title":"Request & Response","permalink":"/balda-js/docs/core-concepts/request-response"},"next":{"title":"Plugins Overview","permalink":"/balda-js/docs/plugins/overview"}}');var a=n(4848),i=n(8453);const t={sidebar_position:6},o="Hashing",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Hashing Passwords",id:"hashing-passwords",level:3},{value:"Verifying Passwords",id:"verifying-passwords",level:3},{value:"Complete Authentication Example",id:"complete-authentication-example",level:2},{value:"Security Features",id:"security-features",level:2},{value:"Salt Generation",id:"salt-generation",level:3},{value:"Hash Format",id:"hash-format",level:3},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Password Strength Validation",id:"password-strength-validation",level:3},{value:"Password Reset Flow",id:"password-reset-flow",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Input Validation",id:"input-validation",level:3},{value:"Empty String Handling",id:"empty-string-handling",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Hashing Performance",id:"hashing-performance",level:3},{value:"Async Operations",id:"async-operations",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"1. Never Store Plain Text Passwords",id:"1-never-store-plain-text-passwords",level:3},{value:"2. Use Strong Password Requirements",id:"2-use-strong-password-requirements",level:3},{value:"3. Implement Rate Limiting",id:"3-implement-rate-limiting",level:3},{value:"4. Use HTTPS in Production",id:"4-use-https-in-production",level:3},{value:"5. Log Security Events",id:"5-log-security-events",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"<code>server.hash(data: string): Promise&lt;string&gt;</code>",id:"serverhashdata-string-promisestring",level:3},{value:"<code>server.compareHash(hash: string, data: string): Promise&lt;boolean&gt;</code>",id:"servercomparehashhash-string-data-string-promiseboolean",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debugging",id:"debugging",level:3}];function c(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"hashing",children:"Hashing"})}),"\n",(0,a.jsx)(s.p,{children:"Balda.js provides built-in secure password hashing functionality using industry-standard PBKDF2 with SHA-256. This feature is essential for securely storing user passwords and sensitive data."}),"\n",(0,a.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(s.p,{children:"The hashing system in Balda.js uses:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"PBKDF2"})," (Password-Based Key Derivation Function 2) algorithm"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"SHA-256"})," as the underlying hash function"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"600,000 iterations"})," for enhanced security"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"16-byte random salt"})," for each hash"]}),"\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.strong,{children:"256-bit (32-byte) hash output"})}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(s.h3,{id:"hashing-passwords",children:"Hashing Passwords"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"import { Server } from 'balda-js';\n\nconst server = new Server();\n\n// Hash a password\nconst password = 'user-password-123';\nconst hashedPassword = await server.hash(password);\n\nconsole.log(hashedPassword);\n// Output: \"salt:hash\" (base64 encoded)\n"})}),"\n",(0,a.jsx)(s.h3,{id:"verifying-passwords",children:"Verifying Passwords"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"// Verify a password against its hash\nconst isValid = await server.compareHash(hashedPassword, password);\n\nif (isValid) {\n  console.log('Password is correct');\n} else {\n  console.log('Password is incorrect');\n}\n"})}),"\n",(0,a.jsx)(s.h2,{id:"complete-authentication-example",children:"Complete Authentication Example"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"import { Server } from 'balda-js';\nimport { controller, post, get } from 'balda-js';\n\n@controller('/auth')\nexport class AuthController {\n  private users = new Map<string, string>(); // In production, use a database\n\n  @post('/register')\n  async register(req: Request, res: Response) {\n    const { email, password } = req.body;\n\n    if (!email || !password) {\n      return res.badRequest({ error: 'Email and password are required' });\n    }\n\n    if (this.users.has(email)) {\n      return res.conflict({ error: 'User already exists' });\n    }\n\n    // Hash the password\n    const hashedPassword = await server.hash(password);\n    this.users.set(email, hashedPassword);\n\n    res.created({ message: 'User registered successfully' });\n  }\n\n  @post('/login')\n  async login(req: Request, res: Response) {\n    const { email, password } = req.body;\n\n    if (!email || !password) {\n      return res.badRequest({ error: 'Email and password are required' });\n    }\n\n    const hashedPassword = this.users.get(email);\n    if (!hashedPassword) {\n      return res.unauthorized({ error: 'Invalid credentials' });\n    }\n\n    // Verify the password\n    const isValid = await server.compareHash(hashedPassword, password);\n\n    if (!isValid) {\n      return res.unauthorized({ error: 'Invalid credentials' });\n    }\n\n    res.json({ message: 'Login successful', token: 'jwt-token-here' });\n  }\n\n  @get('/profile')\n  async getProfile(req: Request, res: Response) {\n    // This would be protected by authentication middleware\n    res.json({ user: 'authenticated-user' });\n  }\n}\n"})}),"\n",(0,a.jsx)(s.h2,{id:"security-features",children:"Security Features"}),"\n",(0,a.jsx)(s.h3,{id:"salt-generation",children:"Salt Generation"}),"\n",(0,a.jsx)(s.p,{children:"Each password hash includes a unique, cryptographically secure random salt:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"const password = 'my-password';\nconst hash1 = await server.hash(password);\nconst hash2 = await server.hash(password);\n\n// Different hashes due to different salts\nconsole.log(hash1 !== hash2); // true\n\n// But both verify correctly\nconst isValid1 = await server.compareHash(hash1, password);\nconst isValid2 = await server.compareHash(hash2, password);\n\nconsole.log(isValid1 && isValid2); // true\n"})}),"\n",(0,a.jsx)(s.h3,{id:"hash-format",children:"Hash Format"}),"\n",(0,a.jsxs)(s.p,{children:["The hash format is ",(0,a.jsx)(s.code,{children:"salt:hash"})," where both parts are base64-encoded:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"const hash = await server.hash('password');\nconst [salt, hashPart] = hash.split(':');\n\nconsole.log('Salt (base64):', salt);\nconsole.log('Hash (base64):', hashPart);\n"})}),"\n",(0,a.jsx)(s.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,a.jsx)(s.h3,{id:"password-strength-validation",children:"Password Strength Validation"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"function validatePasswordStrength(password: string): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (password.length < 8) {\n    errors.push('Password must be at least 8 characters long');\n  }\n\n  if (!/[A-Z]/.test(password)) {\n    errors.push('Password must contain at least one uppercase letter');\n  }\n\n  if (!/[a-z]/.test(password)) {\n    errors.push('Password must contain at least one lowercase letter');\n  }\n\n  if (!/[0-9]/.test(password)) {\n    errors.push('Password must contain at least one number');\n  }\n\n  if (!/[^A-Za-z0-9]/.test(password)) {\n    errors.push('Password must contain at least one special character');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n\n@post('/register')\nasync register(req: Request, res: Response) {\n  const { email, password } = req.body;\n\n  const validation = validatePasswordStrength(password);\n  if (!validation.valid) {\n    return res.badRequest({\n      error: 'Password does not meet requirements',\n      details: validation.errors\n    });\n  }\n\n  const hashedPassword = await server.hash(password);\n  // Store user...\n}\n"})}),"\n",(0,a.jsx)(s.h3,{id:"password-reset-flow",children:"Password Reset Flow"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"@post('/forgot-password')\nasync forgotPassword(req: Request, res: Response) {\n  const { email } = req.body;\n\n  // Generate reset token\n  const resetToken = crypto.randomBytes(32).toString('hex');\n  const resetTokenHash = await server.hash(resetToken);\n\n  // Store reset token with expiration\n  await storeResetToken(email, resetTokenHash, Date.now() + 3600000); // 1 hour\n\n  // Send email with reset link\n  await sendResetEmail(email, resetToken);\n\n  res.json({ message: 'Password reset email sent' });\n}\n\n@post('/reset-password')\nasync resetPassword(req: Request, res: Response) {\n  const { token, newPassword } = req.body;\n\n  // Find user by reset token\n  const user = await findUserByResetToken(token);\n  if (!user || user.resetTokenExpires < Date.now()) {\n    return res.badRequest({ error: 'Invalid or expired reset token' });\n  }\n\n  // Verify the token\n  const isValidToken = await server.compareHash(user.resetTokenHash, token);\n  if (!isValidToken) {\n    return res.badRequest({ error: 'Invalid reset token' });\n  }\n\n  // Hash new password\n  const hashedPassword = await server.hash(newPassword);\n\n  // Update user password and clear reset token\n  await updateUserPassword(user.email, hashedPassword);\n  await clearResetToken(user.email);\n\n  res.json({ message: 'Password reset successfully' });\n}\n"})}),"\n",(0,a.jsx)(s.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(s.h3,{id:"input-validation",children:"Input Validation"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"@post('/change-password')\nasync changePassword(req: Request, res: Response) {\n  const { currentPassword, newPassword } = req.body;\n\n  if (!currentPassword || !newPassword) {\n    return res.badRequest({ error: 'Current and new passwords are required' });\n  }\n\n  if (newPassword.length < 8) {\n    return res.badRequest({ error: 'New password must be at least 8 characters' });\n  }\n\n  // Get user's current password hash\n  const user = await getUserByEmail(req.user.email);\n  const isCurrentPasswordValid = await server.compareHash(user.passwordHash, currentPassword);\n\n  if (!isCurrentPasswordValid) {\n    return res.unauthorized({ error: 'Current password is incorrect' });\n  }\n\n  // Hash new password\n  const newPasswordHash = await server.hash(newPassword);\n  await updateUserPassword(user.email, newPasswordHash);\n\n  res.json({ message: 'Password changed successfully' });\n}\n"})}),"\n",(0,a.jsx)(s.h3,{id:"empty-string-handling",children:"Empty String Handling"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"// This will throw an error\ntry {\n  await server.hash('');\n} catch (error) {\n  console.log(error.message); // \"Data to hash cannot be empty\"\n}\n\n// Handle empty inputs gracefully\nasync function safeHash(password: string): Promise<string | null> {\n  if (!password || password.trim() === '') {\n    return null;\n  }\n  return await server.hash(password);\n}\n"})}),"\n",(0,a.jsx)(s.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(s.h3,{id:"hashing-performance",children:"Hashing Performance"}),"\n",(0,a.jsx)(s.p,{children:"The PBKDF2 algorithm with 600,000 iterations is intentionally slow to prevent brute-force attacks:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"// Benchmark hashing performance\nasync function benchmarkHashing() {\n  const password = 'test-password';\n  const iterations = 10;\n\n  console.time('Hashing Performance');\n\n  for (let i = 0; i < iterations; i++) {\n    await server.hash(password);\n  }\n\n  console.timeEnd('Hashing Performance');\n  // Typical result: ~2-5 seconds for 10 hashes\n}\n"})}),"\n",(0,a.jsx)(s.h3,{id:"async-operations",children:"Async Operations"}),"\n",(0,a.jsxs)(s.p,{children:["Always use ",(0,a.jsx)(s.code,{children:"await"})," when hashing or comparing:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"// Correct - async/await\nconst hash = await server.hash(password);\nconst isValid = await server.compareHash(hash, password);\n\n// Incorrect - missing await\nconst hash = server.hash(password); // Returns Promise<string>\nconst isValid = server.compareHash(hash, password); // Returns Promise<boolean>\n"})}),"\n",(0,a.jsx)(s.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,a.jsx)(s.h3,{id:"1-never-store-plain-text-passwords",children:"1. Never Store Plain Text Passwords"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"// \u274c Never do this\nconst user = {\n  email: 'user@example.com',\n  password: 'plain-text-password' // NEVER!\n};\n\n// \u2705 Always hash passwords\nconst user = {\n  email: 'user@example.com',\n  passwordHash: await server.hash('user-password')\n};\n"})}),"\n",(0,a.jsx)(s.h3,{id:"2-use-strong-password-requirements",children:"2. Use Strong Password Requirements"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"const passwordRequirements = {\n  minLength: 12,\n  requireUppercase: true,\n  requireLowercase: true,\n  requireNumbers: true,\n  requireSpecialChars: true,\n  maxLength: 128\n};\n"})}),"\n",(0,a.jsx)(s.h3,{id:"3-implement-rate-limiting",children:"3. Implement Rate Limiting"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"import { rateLimiter } from 'balda-js';\n\n// Rate limit login attempts\nserver.use('/auth/login', rateLimiter({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 attempts per window\n  message: 'Too many login attempts'\n}));\n"})}),"\n",(0,a.jsx)(s.h3,{id:"4-use-https-in-production",children:"4. Use HTTPS in Production"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"// Ensure HTTPS is used for password transmission\nif (process.env.NODE_ENV === 'production' && !req.secure) {\n  return res.redirect(`https://${req.get('host')}${req.url}`);\n}\n"})}),"\n",(0,a.jsx)(s.h3,{id:"5-log-security-events",children:"5. Log Security Events"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"@post('/login')\nasync login(req: Request, res: Response) {\n  const { email, password } = req.body;\n\n  const user = await getUserByEmail(email);\n  if (!user) {\n    // Log failed login attempt\n    logger.warn(`Failed login attempt for non-existent user: ${email}`, {\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n    return res.unauthorized({ error: 'Invalid credentials' });\n  }\n\n  const isValid = await server.compareHash(user.passwordHash, password);\n  if (!isValid) {\n    // Log failed login attempt\n    logger.warn(`Failed login attempt for user: ${email}`, {\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n    return res.unauthorized({ error: 'Invalid credentials' });\n  }\n\n  // Log successful login\n  logger.info(`Successful login for user: ${email}`, {\n    ip: req.ip,\n    userAgent: req.get('User-Agent')\n  });\n\n  res.json({ token: generateJWT(user) });\n}\n"})}),"\n",(0,a.jsx)(s.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,a.jsx)(s.h3,{id:"serverhashdata-string-promisestring",children:(0,a.jsx)(s.code,{children:"server.hash(data: string): Promise<string>"})}),"\n",(0,a.jsx)(s.p,{children:"Hashes a string using PBKDF2 with SHA-256."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"data"})," (string): The string to hash"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"Promise<string>"}),": A base64-encoded string in format ",(0,a.jsx)(s.code,{children:"salt:hash"})]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Throws:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"Error"}),": If data is empty or null"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Example:"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"const hash = await server.hash('my-password');\nconsole.log(hash); // \"dGVzdC1zYWx0:dGVzdC1oYXNo\"\n"})}),"\n",(0,a.jsx)(s.h3,{id:"servercomparehashhash-string-data-string-promiseboolean",children:(0,a.jsx)(s.code,{children:"server.compareHash(hash: string, data: string): Promise<boolean>"})}),"\n",(0,a.jsx)(s.p,{children:"Compares a string against a hash."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"hash"})," (string): The hash to compare against (format: ",(0,a.jsx)(s.code,{children:"salt:hash"}),")"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"data"})," (string): The string to verify"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"Promise<boolean>"}),": ",(0,a.jsx)(s.code,{children:"true"})," if the data matches the hash, ",(0,a.jsx)(s.code,{children:"false"})," otherwise"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Example:"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"const hash = await server.hash('my-password');\nconst isValid = await server.compareHash(hash, 'my-password');\nconsole.log(isValid); // true\n\nconst isInvalid = await server.compareHash(hash, 'wrong-password');\nconsole.log(isInvalid); // false\n"})}),"\n",(0,a.jsx)(s.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(s.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:'"Data to hash cannot be empty" error'})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Ensure you're not passing empty strings or null values"}),"\n",(0,a.jsx)(s.li,{children:"Add input validation before hashing"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Hash comparison always returns false"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Check that you're using the correct hash format"}),"\n",(0,a.jsx)(s.li,{children:"Ensure the hash wasn't corrupted during storage"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Performance issues with hashing"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"The 600,000 iterations are intentional for security"}),"\n",(0,a.jsx)(s.li,{children:"Consider using background jobs for bulk operations"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"debugging",children:"Debugging"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"// Enable debug logging\nconst server = new Server({\n  debug: true\n});\n\n// Log hash operations (remove in production)\nconst originalHash = server.hash;\nserver.hash = async function(data: string) {\n  console.log('Hashing data:', data.substring(0, 3) + '...');\n  const result = await originalHash.call(this, data);\n  console.log('Hash result:', result.substring(0, 10) + '...');\n  return result;\n};\n"})}),"\n",(0,a.jsx)(s.p,{children:"The hashing functionality in Balda.js provides enterprise-grade security for password management while maintaining ease of use and excellent performance characteristics."})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>o});var r=n(6540);const a={},i=r.createContext(a);function t(e){const s=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);